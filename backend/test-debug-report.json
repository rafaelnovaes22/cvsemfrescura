{
  "timestamp": "2025-07-31T03:23:24.827Z",
  "summary": {
    "total": 10,
    "passed": 2,
    "failed": 8,
    "notFound": 0
  },
  "details": [
    {
      "file": "tests/unit/controllers/userController.test.js",
      "status": "PASSED",
      "output": ""
    },
    {
      "file": "tests/unit/controllers/giftCodeController.test.js",
      "status": "PASSED",
      "output": ""
    },
    {
      "file": "tests/unit/controllers/paymentController.test.js",
      "status": "FAILED",
      "error": "Command failed: npx jest \"tests/unit/controllers/paymentController.test.js\" --verbose --no-coverage --silent\nFAIL tests/unit/controllers/paymentController.test.js\n  PaymentController\n    createPaymentIntent\n      × deve criar payment intent com sucesso (7 ms)\n      × deve retornar erro quando usuário não é encontrado (1 ms)\n      √ deve retornar erro quando parâmetros são inválidos\n      × deve retornar erro quando valor é menor que mínimo (1 ms)\n      × deve tratar erros do Stripe\n      × deve incluir metadados corretos no payment intent (1 ms)\n    confirmPayment\n      × deve confirmar pagamento com sucesso\n      × deve retornar erro quando payment intent não é encontrado (1 ms)\n      × deve retornar erro quando pagamento não foi bem-sucedido\n      × deve tratar transação que não existe no banco\n      × deve evitar processar transação já completada (2 ms)\n    handleWebhook\n      × deve processar webhook de pagamento bem-sucedido\n      × deve retornar erro quando assinatura é inválida\n      × deve ignorar eventos não relacionados a pagamento (1 ms)\n      × deve lidar com webhook de pagamento falho\n    getTransactionHistory\n      × deve retornar histórico de transações do usuário (54 ms)\n      × deve retornar lista vazia quando usuário não tem transações\n      √ deve tratar erros ao buscar histórico (1 ms)\n\n  ● PaymentController › createPaymentIntent › deve criar payment intent com sucesso\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: 1\n\n    Number of calls: 0\n\n    \u001b[0m \u001b[90m  99 |\u001b[39m\n     \u001b[90m 100 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 101 |\u001b[39m       expect(\u001b[33mUser\u001b[39m\u001b[33m.\u001b[39mfindByPk)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\u001b[35m1\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                             \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 102 |\u001b[39m       expect(mockStripe\u001b[33m.\u001b[39mpaymentIntents\u001b[33m.\u001b[39mcreate)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m 103 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 104 |\u001b[39m           amount\u001b[33m:\u001b[39m \u001b[35m1000\u001b[39m\u001b[33m,\u001b[39m\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/paymentController.test.js:101:29)\n\n  ● PaymentController › createPaymentIntent › deve retornar erro quando usuário não é encontrado\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: 404\n    Received: 400\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m  99 |\u001b[39m\n     \u001b[90m 100 |\u001b[39m \u001b[36mconst\u001b[39m expectErrorResponse \u001b[33m=\u001b[39m (res\u001b[33m,\u001b[39m expectedStatus\u001b[33m,\u001b[39m expectedMessage \u001b[33m=\u001b[39m \u001b[36mnull\u001b[39m) \u001b[33m=>\u001b[39m {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 101 |\u001b[39m     expect(res\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(expectedStatus)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 102 |\u001b[39m     expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 103 |\u001b[39m\n     \u001b[90m 104 |\u001b[39m     \u001b[36mif\u001b[39m (expectedMessage) {\u001b[0m\n\n      at toHaveBeenCalledWith (tests/helpers/testHelpers.js:101:24)\n      at Object.expectErrorResponse (tests/unit/controllers/paymentController.test.js:135:7)\n\n  ● PaymentController › createPaymentIntent › deve retornar erro quando valor é menor que mínimo\n\n    expect(received).toContain(expected) // indexOf\n\n    Expected substring: \"mínimo\"\n    Received string:    \"Informações de pagamento incompletas\"\n\n    \u001b[0m \u001b[90m 106 |\u001b[39m         expect(jsonCall\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoBeDefined()\u001b[33m;\u001b[39m\n     \u001b[90m 107 |\u001b[39m         \u001b[36mif\u001b[39m (\u001b[36mtypeof\u001b[39m expectedMessage \u001b[33m===\u001b[39m \u001b[32m'string'\u001b[39m) {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 108 |\u001b[39m             expect(jsonCall\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(expectedMessage)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                    \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 109 |\u001b[39m         }\n     \u001b[90m 110 |\u001b[39m     }\n     \u001b[90m 111 |\u001b[39m }\u001b[33m;\u001b[39m\u001b[0m\n\n      at toContain (tests/helpers/testHelpers.js:108:36)\n      at Object.expectErrorResponse (tests/unit/controllers/paymentController.test.js:159:7)\n\n  ● PaymentController › createPaymentIntent › deve tratar erros do Stripe\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: 500\n    Received: 400\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m  99 |\u001b[39m\n     \u001b[90m 100 |\u001b[39m \u001b[36mconst\u001b[39m expectErrorResponse \u001b[33m=\u001b[39m (res\u001b[33m,\u001b[39m expectedStatus\u001b[33m,\u001b[39m expectedMessage \u001b[33m=\u001b[39m \u001b[36mnull\u001b[39m) \u001b[33m=>\u001b[39m {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 101 |\u001b[39m     expect(res\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(expectedStatus)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 102 |\u001b[39m     expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 103 |\u001b[39m\n     \u001b[90m 104 |\u001b[39m     \u001b[36mif\u001b[39m (expectedMessage) {\u001b[0m\n\n      at toHaveBeenCalledWith (tests/helpers/testHelpers.js:101:24)\n      at Object.expectErrorResponse (tests/unit/controllers/paymentController.test.js:173:7)\n\n  ● PaymentController › createPaymentIntent › deve incluir metadados corretos no payment intent\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"metadata\": ObjectContaining {\"credits\": \"10\", \"plan\": \"premium\", \"userId\": \"1\"}}\n\n    Number of calls: 0\n\n    \u001b[0m \u001b[90m 188 |\u001b[39m\n     \u001b[90m 189 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 190 |\u001b[39m       expect(mockStripe\u001b[33m.\u001b[39mpaymentIntents\u001b[33m.\u001b[39mcreate)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m     |\u001b[39m                                                \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 191 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 192 |\u001b[39m           metadata\u001b[33m:\u001b[39m expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 193 |\u001b[39m             userId\u001b[33m:\u001b[39m \u001b[32m'1'\u001b[39m\u001b[33m,\u001b[39m\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/paymentController.test.js:190:48)\n\n  ● PaymentController › confirmPayment › deve confirmar pagamento com sucesso\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: \"pi_test123\"\n\n    Number of calls: 0\n\n    \u001b[0m \u001b[90m 236 |\u001b[39m\n     \u001b[90m 237 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 238 |\u001b[39m       expect(mockStripe\u001b[33m.\u001b[39mpaymentIntents\u001b[33m.\u001b[39mretrieve)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\u001b[32m'pi_test123'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                                  \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 239 |\u001b[39m       expect(mockTransaction\u001b[33m.\u001b[39mupdate)\u001b[33m.\u001b[39mtoHaveBeenCalledWith({ status\u001b[33m:\u001b[39m \u001b[32m'completed'\u001b[39m })\u001b[33m;\u001b[39m\n     \u001b[90m 240 |\u001b[39m       expect(mockUserInstance\u001b[33m.\u001b[39mupdate)\u001b[33m.\u001b[39mtoHaveBeenCalledWith({ credits\u001b[33m:\u001b[39m \u001b[35m15\u001b[39m })\u001b[33m;\u001b[39m \u001b[90m// 5 + 10\u001b[39m\n     \u001b[90m 241 |\u001b[39m       expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/paymentController.test.js:238:50)\n\n  ● PaymentController › confirmPayment › deve retornar erro quando payment intent não é encontrado\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: 404\n    Received: 500\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m  99 |\u001b[39m\n     \u001b[90m 100 |\u001b[39m \u001b[36mconst\u001b[39m expectErrorResponse \u001b[33m=\u001b[39m (res\u001b[33m,\u001b[39m expectedStatus\u001b[33m,\u001b[39m expectedMessage \u001b[33m=\u001b[39m \u001b[36mnull\u001b[39m) \u001b[33m=>\u001b[39m {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 101 |\u001b[39m     expect(res\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(expectedStatus)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 102 |\u001b[39m     expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 103 |\u001b[39m\n     \u001b[90m 104 |\u001b[39m     \u001b[36mif\u001b[39m (expectedMessage) {\u001b[0m\n\n      at toHaveBeenCalledWith (tests/helpers/testHelpers.js:101:24)\n      at Object.expectErrorResponse (tests/unit/controllers/paymentController.test.js:259:7)\n\n  ● PaymentController › confirmPayment › deve retornar erro quando pagamento não foi bem-sucedido\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: 400\n    Received: 500\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m  99 |\u001b[39m\n     \u001b[90m 100 |\u001b[39m \u001b[36mconst\u001b[39m expectErrorResponse \u001b[33m=\u001b[39m (res\u001b[33m,\u001b[39m expectedStatus\u001b[33m,\u001b[39m expectedMessage \u001b[33m=\u001b[39m \u001b[36mnull\u001b[39m) \u001b[33m=>\u001b[39m {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 101 |\u001b[39m     expect(res\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(expectedStatus)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 102 |\u001b[39m     expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 103 |\u001b[39m\n     \u001b[90m 104 |\u001b[39m     \u001b[36mif\u001b[39m (expectedMessage) {\u001b[0m\n\n      at toHaveBeenCalledWith (tests/helpers/testHelpers.js:101:24)\n      at Object.expectErrorResponse (tests/unit/controllers/paymentController.test.js:274:7)\n\n  ● PaymentController › confirmPayment › deve tratar transação que não existe no banco\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: 404\n    Received: 500\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m  99 |\u001b[39m\n     \u001b[90m 100 |\u001b[39m \u001b[36mconst\u001b[39m expectErrorResponse \u001b[33m=\u001b[39m (res\u001b[33m,\u001b[39m expectedStatus\u001b[33m,\u001b[39m expectedMessage \u001b[33m=\u001b[39m \u001b[36mnull\u001b[39m) \u001b[33m=>\u001b[39m {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 101 |\u001b[39m     expect(res\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(expectedStatus)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 102 |\u001b[39m     expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 103 |\u001b[39m\n     \u001b[90m 104 |\u001b[39m     \u001b[36mif\u001b[39m (expectedMessage) {\u001b[0m\n\n      at toHaveBeenCalledWith (tests/helpers/testHelpers.js:101:24)\n      at Object.expectErrorResponse (tests/unit/controllers/paymentController.test.js:290:7)\n\n  ● PaymentController › confirmPayment › deve evitar processar transação já completada\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": StringContaining \"já foi processada\", \"success\": true}\n    Received: {\"details\": \"Cannot read properties of undefined (reading 'status')\", \"error\": \"Erro ao confirmar pagamento\"}\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m 311 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n     \u001b[90m 312 |\u001b[39m       expect(mockCompletedTransaction\u001b[33m.\u001b[39mupdate)\u001b[33m.\u001b[39mnot\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 313 |\u001b[39m       expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 314 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 315 |\u001b[39m           success\u001b[33m:\u001b[39m \u001b[36mtrue\u001b[39m\u001b[33m,\u001b[39m\n     \u001b[90m 316 |\u001b[39m           message\u001b[33m:\u001b[39m expect\u001b[33m.\u001b[39mstringContaining(\u001b[32m'já foi processada'\u001b[39m)\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/paymentController.test.js:313:24)\n\n  ● PaymentController › handleWebhook › deve processar webhook de pagamento bem-sucedido\n\n    TypeError: Cannot read properties of undefined (reading 'type')\n\n    \u001b[0m \u001b[90m 369 |\u001b[39m\n     \u001b[90m 370 |\u001b[39m   \u001b[90m// Handle the event\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 371 |\u001b[39m   \u001b[36mswitch\u001b[39m (event\u001b[33m.\u001b[39mtype) {\n     \u001b[90m     |\u001b[39m                 \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 372 |\u001b[39m     \u001b[36mcase\u001b[39m \u001b[32m'payment_intent.succeeded'\u001b[39m\u001b[33m:\u001b[39m\n     \u001b[90m 373 |\u001b[39m       \u001b[36mconst\u001b[39m paymentIntent \u001b[33m=\u001b[39m event\u001b[33m.\u001b[39mdata\u001b[33m.\u001b[39mobject\u001b[33m;\u001b[39m\n     \u001b[90m 374 |\u001b[39m       \u001b[36mawait\u001b[39m handleSuccessfulPayment(paymentIntent)\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.type [as handleWebhook] (controllers/paymentController.js:371:17)\n      at Object.handleWebhook (tests/unit/controllers/paymentController.test.js:361:31)\n\n  ● PaymentController › handleWebhook › deve retornar erro quando assinatura é inválida\n\n    TypeError: Cannot read properties of undefined (reading 'type')\n\n    \u001b[0m \u001b[90m 369 |\u001b[39m\n     \u001b[90m 370 |\u001b[39m   \u001b[90m// Handle the event\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 371 |\u001b[39m   \u001b[36mswitch\u001b[39m (event\u001b[33m.\u001b[39mtype) {\n     \u001b[90m     |\u001b[39m                 \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 372 |\u001b[39m     \u001b[36mcase\u001b[39m \u001b[32m'payment_intent.succeeded'\u001b[39m\u001b[33m:\u001b[39m\n     \u001b[90m 373 |\u001b[39m       \u001b[36mconst\u001b[39m paymentIntent \u001b[33m=\u001b[39m event\u001b[33m.\u001b[39mdata\u001b[33m.\u001b[39mobject\u001b[33m;\u001b[39m\n     \u001b[90m 374 |\u001b[39m       \u001b[36mawait\u001b[39m handleSuccessfulPayment(paymentIntent)\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.type [as handleWebhook] (controllers/paymentController.js:371:17)\n      at Object.handleWebhook (tests/unit/controllers/paymentController.test.js:381:31)\n\n  ● PaymentController › handleWebhook › deve ignorar eventos não relacionados a pagamento\n\n    TypeError: Cannot read properties of undefined (reading 'type')\n\n    \u001b[0m \u001b[90m 369 |\u001b[39m\n     \u001b[90m 370 |\u001b[39m   \u001b[90m// Handle the event\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 371 |\u001b[39m   \u001b[36mswitch\u001b[39m (event\u001b[33m.\u001b[39mtype) {\n     \u001b[90m     |\u001b[39m                 \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 372 |\u001b[39m     \u001b[36mcase\u001b[39m \u001b[32m'payment_intent.succeeded'\u001b[39m\u001b[33m:\u001b[39m\n     \u001b[90m 373 |\u001b[39m       \u001b[36mconst\u001b[39m paymentIntent \u001b[33m=\u001b[39m event\u001b[33m.\u001b[39mdata\u001b[33m.\u001b[39mobject\u001b[33m;\u001b[39m\n     \u001b[90m 374 |\u001b[39m       \u001b[36mawait\u001b[39m handleSuccessfulPayment(paymentIntent)\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.type [as handleWebhook] (controllers/paymentController.js:371:17)\n      at Object.handleWebhook (tests/unit/controllers/paymentController.test.js:396:31)\n\n  ● PaymentController › handleWebhook › deve lidar com webhook de pagamento falho\n\n    TypeError: Cannot read properties of undefined (reading 'type')\n\n    \u001b[0m \u001b[90m 369 |\u001b[39m\n     \u001b[90m 370 |\u001b[39m   \u001b[90m// Handle the event\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 371 |\u001b[39m   \u001b[36mswitch\u001b[39m (event\u001b[33m.\u001b[39mtype) {\n     \u001b[90m     |\u001b[39m                 \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 372 |\u001b[39m     \u001b[36mcase\u001b[39m \u001b[32m'payment_intent.succeeded'\u001b[39m\u001b[33m:\u001b[39m\n     \u001b[90m 373 |\u001b[39m       \u001b[36mconst\u001b[39m paymentIntent \u001b[33m=\u001b[39m event\u001b[33m.\u001b[39mdata\u001b[33m.\u001b[39mobject\u001b[33m;\u001b[39m\n     \u001b[90m 374 |\u001b[39m       \u001b[36mawait\u001b[39m handleSuccessfulPayment(paymentIntent)\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.type [as handleWebhook] (controllers/paymentController.js:371:17)\n      at Object.handleWebhook (tests/unit/controllers/paymentController.test.js:424:31)\n\n  ● PaymentController › getTransactionHistory › deve retornar histórico de transações do usuário\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"order\": [[\"createdAt\", \"DESC\"]], \"where\": {\"userId\": 1}}\n    Received: {\"order\": [[\"createdAt\", \"DESC\"]], \"where\": {\"status\": {Symbol(in): [\"completed\", \"failed\", \"refunded\"]}, \"userId\": 1}}\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m 460 |\u001b[39m\n     \u001b[90m 461 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 462 |\u001b[39m       expect(\u001b[33mTransaction\u001b[39m\u001b[33m.\u001b[39mfindAll)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m     |\u001b[39m                                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 463 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 464 |\u001b[39m           where\u001b[33m:\u001b[39m { userId\u001b[33m:\u001b[39m \u001b[35m1\u001b[39m }\u001b[33m,\u001b[39m\n     \u001b[90m 465 |\u001b[39m           order\u001b[33m:\u001b[39m [[\u001b[32m'createdAt'\u001b[39m\u001b[33m,\u001b[39m \u001b[32m'DESC'\u001b[39m]]\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/paymentController.test.js:462:35)\n\n  ● PaymentController › getTransactionHistory › deve retornar lista vazia quando usuário não tem transações\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"success\": true, \"transactions\": []}\n    Received: []\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m 482 |\u001b[39m\n     \u001b[90m 483 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 484 |\u001b[39m       expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 485 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 486 |\u001b[39m           success\u001b[33m:\u001b[39m \u001b[36mtrue\u001b[39m\u001b[33m,\u001b[39m\n     \u001b[90m 487 |\u001b[39m           transactions\u001b[33m:\u001b[39m []\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/paymentController.test.js:484:24)\n\nTest Suites: 1 failed, 1 total\nTests:       16 failed, 2 passed, 18 total\nSnapshots:   0 total\nTime:        1.285 s, estimated 3 s\n",
      "stderr": "FAIL tests/unit/controllers/paymentController.test.js\n  PaymentController\n    createPaymentIntent\n      × deve criar payment intent com sucesso (7 ms)\n      × deve retornar erro quando usuário não é encontrado (1 ms)\n      √ deve retornar erro quando parâmetros são inválidos\n      × deve retornar erro quando valor é menor que mínimo (1 ms)\n      × deve tratar erros do Stripe\n      × deve incluir metadados corretos no payment intent (1 ms)\n    confirmPayment\n      × deve confirmar pagamento com sucesso\n      × deve retornar erro quando payment intent não é encontrado (1 ms)\n      × deve retornar erro quando pagamento não foi bem-sucedido\n      × deve tratar transação que não existe no banco\n      × deve evitar processar transação já completada (2 ms)\n    handleWebhook\n      × deve processar webhook de pagamento bem-sucedido\n      × deve retornar erro quando assinatura é inválida\n      × deve ignorar eventos não relacionados a pagamento (1 ms)\n      × deve lidar com webhook de pagamento falho\n    getTransactionHistory\n      × deve retornar histórico de transações do usuário (54 ms)\n      × deve retornar lista vazia quando usuário não tem transações\n      √ deve tratar erros ao buscar histórico (1 ms)\n\n  ● PaymentController › createPaymentIntent › deve criar payment intent com sucesso\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: 1\n\n    Number of calls: 0\n\n    \u001b[0m \u001b[90m  99 |\u001b[39m\n     \u001b[90m 100 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 101 |\u001b[39m       expect(\u001b[33mUser\u001b[39m\u001b[33m.\u001b[39mfindByPk)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\u001b[35m1\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                             \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 102 |\u001b[39m       expect(mockStripe\u001b[33m.\u001b[39mpaymentIntents\u001b[33m.\u001b[39mcreate)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m 103 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 104 |\u001b[39m           amount\u001b[33m:\u001b[39m \u001b[35m1000\u001b[39m\u001b[33m,\u001b[39m\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/paymentController.test.js:101:29)\n\n  ● PaymentController › createPaymentIntent › deve retornar erro quando usuário não é encontrado\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: 404\n    Received: 400\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m  99 |\u001b[39m\n     \u001b[90m 100 |\u001b[39m \u001b[36mconst\u001b[39m expectErrorResponse \u001b[33m=\u001b[39m (res\u001b[33m,\u001b[39m expectedStatus\u001b[33m,\u001b[39m expectedMessage \u001b[33m=\u001b[39m \u001b[36mnull\u001b[39m) \u001b[33m=>\u001b[39m {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 101 |\u001b[39m     expect(res\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(expectedStatus)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 102 |\u001b[39m     expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 103 |\u001b[39m\n     \u001b[90m 104 |\u001b[39m     \u001b[36mif\u001b[39m (expectedMessage) {\u001b[0m\n\n      at toHaveBeenCalledWith (tests/helpers/testHelpers.js:101:24)\n      at Object.expectErrorResponse (tests/unit/controllers/paymentController.test.js:135:7)\n\n  ● PaymentController › createPaymentIntent › deve retornar erro quando valor é menor que mínimo\n\n    expect(received).toContain(expected) // indexOf\n\n    Expected substring: \"mínimo\"\n    Received string:    \"Informações de pagamento incompletas\"\n\n    \u001b[0m \u001b[90m 106 |\u001b[39m         expect(jsonCall\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoBeDefined()\u001b[33m;\u001b[39m\n     \u001b[90m 107 |\u001b[39m         \u001b[36mif\u001b[39m (\u001b[36mtypeof\u001b[39m expectedMessage \u001b[33m===\u001b[39m \u001b[32m'string'\u001b[39m) {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 108 |\u001b[39m             expect(jsonCall\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(expectedMessage)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                    \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 109 |\u001b[39m         }\n     \u001b[90m 110 |\u001b[39m     }\n     \u001b[90m 111 |\u001b[39m }\u001b[33m;\u001b[39m\u001b[0m\n\n      at toContain (tests/helpers/testHelpers.js:108:36)\n      at Object.expectErrorResponse (tests/unit/controllers/paymentController.test.js:159:7)\n\n  ● PaymentController › createPaymentIntent › deve tratar erros do Stripe\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: 500\n    Received: 400\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m  99 |\u001b[39m\n     \u001b[90m 100 |\u001b[39m \u001b[36mconst\u001b[39m expectErrorResponse \u001b[33m=\u001b[39m (res\u001b[33m,\u001b[39m expectedStatus\u001b[33m,\u001b[39m expectedMessage \u001b[33m=\u001b[39m \u001b[36mnull\u001b[39m) \u001b[33m=>\u001b[39m {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 101 |\u001b[39m     expect(res\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(expectedStatus)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 102 |\u001b[39m     expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 103 |\u001b[39m\n     \u001b[90m 104 |\u001b[39m     \u001b[36mif\u001b[39m (expectedMessage) {\u001b[0m\n\n      at toHaveBeenCalledWith (tests/helpers/testHelpers.js:101:24)\n      at Object.expectErrorResponse (tests/unit/controllers/paymentController.test.js:173:7)\n\n  ● PaymentController › createPaymentIntent › deve incluir metadados corretos no payment intent\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"metadata\": ObjectContaining {\"credits\": \"10\", \"plan\": \"premium\", \"userId\": \"1\"}}\n\n    Number of calls: 0\n\n    \u001b[0m \u001b[90m 188 |\u001b[39m\n     \u001b[90m 189 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 190 |\u001b[39m       expect(mockStripe\u001b[33m.\u001b[39mpaymentIntents\u001b[33m.\u001b[39mcreate)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m     |\u001b[39m                                                \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 191 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 192 |\u001b[39m           metadata\u001b[33m:\u001b[39m expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 193 |\u001b[39m             userId\u001b[33m:\u001b[39m \u001b[32m'1'\u001b[39m\u001b[33m,\u001b[39m\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/paymentController.test.js:190:48)\n\n  ● PaymentController › confirmPayment › deve confirmar pagamento com sucesso\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: \"pi_test123\"\n\n    Number of calls: 0\n\n    \u001b[0m \u001b[90m 236 |\u001b[39m\n     \u001b[90m 237 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 238 |\u001b[39m       expect(mockStripe\u001b[33m.\u001b[39mpaymentIntents\u001b[33m.\u001b[39mretrieve)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\u001b[32m'pi_test123'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                                  \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 239 |\u001b[39m       expect(mockTransaction\u001b[33m.\u001b[39mupdate)\u001b[33m.\u001b[39mtoHaveBeenCalledWith({ status\u001b[33m:\u001b[39m \u001b[32m'completed'\u001b[39m })\u001b[33m;\u001b[39m\n     \u001b[90m 240 |\u001b[39m       expect(mockUserInstance\u001b[33m.\u001b[39mupdate)\u001b[33m.\u001b[39mtoHaveBeenCalledWith({ credits\u001b[33m:\u001b[39m \u001b[35m15\u001b[39m })\u001b[33m;\u001b[39m \u001b[90m// 5 + 10\u001b[39m\n     \u001b[90m 241 |\u001b[39m       expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/paymentController.test.js:238:50)\n\n  ● PaymentController › confirmPayment › deve retornar erro quando payment intent não é encontrado\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: 404\n    Received: 500\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m  99 |\u001b[39m\n     \u001b[90m 100 |\u001b[39m \u001b[36mconst\u001b[39m expectErrorResponse \u001b[33m=\u001b[39m (res\u001b[33m,\u001b[39m expectedStatus\u001b[33m,\u001b[39m expectedMessage \u001b[33m=\u001b[39m \u001b[36mnull\u001b[39m) \u001b[33m=>\u001b[39m {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 101 |\u001b[39m     expect(res\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(expectedStatus)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 102 |\u001b[39m     expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 103 |\u001b[39m\n     \u001b[90m 104 |\u001b[39m     \u001b[36mif\u001b[39m (expectedMessage) {\u001b[0m\n\n      at toHaveBeenCalledWith (tests/helpers/testHelpers.js:101:24)\n      at Object.expectErrorResponse (tests/unit/controllers/paymentController.test.js:259:7)\n\n  ● PaymentController › confirmPayment › deve retornar erro quando pagamento não foi bem-sucedido\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: 400\n    Received: 500\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m  99 |\u001b[39m\n     \u001b[90m 100 |\u001b[39m \u001b[36mconst\u001b[39m expectErrorResponse \u001b[33m=\u001b[39m (res\u001b[33m,\u001b[39m expectedStatus\u001b[33m,\u001b[39m expectedMessage \u001b[33m=\u001b[39m \u001b[36mnull\u001b[39m) \u001b[33m=>\u001b[39m {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 101 |\u001b[39m     expect(res\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(expectedStatus)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 102 |\u001b[39m     expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 103 |\u001b[39m\n     \u001b[90m 104 |\u001b[39m     \u001b[36mif\u001b[39m (expectedMessage) {\u001b[0m\n\n      at toHaveBeenCalledWith (tests/helpers/testHelpers.js:101:24)\n      at Object.expectErrorResponse (tests/unit/controllers/paymentController.test.js:274:7)\n\n  ● PaymentController › confirmPayment › deve tratar transação que não existe no banco\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: 404\n    Received: 500\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m  99 |\u001b[39m\n     \u001b[90m 100 |\u001b[39m \u001b[36mconst\u001b[39m expectErrorResponse \u001b[33m=\u001b[39m (res\u001b[33m,\u001b[39m expectedStatus\u001b[33m,\u001b[39m expectedMessage \u001b[33m=\u001b[39m \u001b[36mnull\u001b[39m) \u001b[33m=>\u001b[39m {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 101 |\u001b[39m     expect(res\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(expectedStatus)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 102 |\u001b[39m     expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 103 |\u001b[39m\n     \u001b[90m 104 |\u001b[39m     \u001b[36mif\u001b[39m (expectedMessage) {\u001b[0m\n\n      at toHaveBeenCalledWith (tests/helpers/testHelpers.js:101:24)\n      at Object.expectErrorResponse (tests/unit/controllers/paymentController.test.js:290:7)\n\n  ● PaymentController › confirmPayment › deve evitar processar transação já completada\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"message\": StringContaining \"já foi processada\", \"success\": true}\n    Received: {\"details\": \"Cannot read properties of undefined (reading 'status')\", \"error\": \"Erro ao confirmar pagamento\"}\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m 311 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n     \u001b[90m 312 |\u001b[39m       expect(mockCompletedTransaction\u001b[33m.\u001b[39mupdate)\u001b[33m.\u001b[39mnot\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 313 |\u001b[39m       expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 314 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 315 |\u001b[39m           success\u001b[33m:\u001b[39m \u001b[36mtrue\u001b[39m\u001b[33m,\u001b[39m\n     \u001b[90m 316 |\u001b[39m           message\u001b[33m:\u001b[39m expect\u001b[33m.\u001b[39mstringContaining(\u001b[32m'já foi processada'\u001b[39m)\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/paymentController.test.js:313:24)\n\n  ● PaymentController › handleWebhook › deve processar webhook de pagamento bem-sucedido\n\n    TypeError: Cannot read properties of undefined (reading 'type')\n\n    \u001b[0m \u001b[90m 369 |\u001b[39m\n     \u001b[90m 370 |\u001b[39m   \u001b[90m// Handle the event\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 371 |\u001b[39m   \u001b[36mswitch\u001b[39m (event\u001b[33m.\u001b[39mtype) {\n     \u001b[90m     |\u001b[39m                 \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 372 |\u001b[39m     \u001b[36mcase\u001b[39m \u001b[32m'payment_intent.succeeded'\u001b[39m\u001b[33m:\u001b[39m\n     \u001b[90m 373 |\u001b[39m       \u001b[36mconst\u001b[39m paymentIntent \u001b[33m=\u001b[39m event\u001b[33m.\u001b[39mdata\u001b[33m.\u001b[39mobject\u001b[33m;\u001b[39m\n     \u001b[90m 374 |\u001b[39m       \u001b[36mawait\u001b[39m handleSuccessfulPayment(paymentIntent)\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.type [as handleWebhook] (controllers/paymentController.js:371:17)\n      at Object.handleWebhook (tests/unit/controllers/paymentController.test.js:361:31)\n\n  ● PaymentController › handleWebhook › deve retornar erro quando assinatura é inválida\n\n    TypeError: Cannot read properties of undefined (reading 'type')\n\n    \u001b[0m \u001b[90m 369 |\u001b[39m\n     \u001b[90m 370 |\u001b[39m   \u001b[90m// Handle the event\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 371 |\u001b[39m   \u001b[36mswitch\u001b[39m (event\u001b[33m.\u001b[39mtype) {\n     \u001b[90m     |\u001b[39m                 \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 372 |\u001b[39m     \u001b[36mcase\u001b[39m \u001b[32m'payment_intent.succeeded'\u001b[39m\u001b[33m:\u001b[39m\n     \u001b[90m 373 |\u001b[39m       \u001b[36mconst\u001b[39m paymentIntent \u001b[33m=\u001b[39m event\u001b[33m.\u001b[39mdata\u001b[33m.\u001b[39mobject\u001b[33m;\u001b[39m\n     \u001b[90m 374 |\u001b[39m       \u001b[36mawait\u001b[39m handleSuccessfulPayment(paymentIntent)\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.type [as handleWebhook] (controllers/paymentController.js:371:17)\n      at Object.handleWebhook (tests/unit/controllers/paymentController.test.js:381:31)\n\n  ● PaymentController › handleWebhook › deve ignorar eventos não relacionados a pagamento\n\n    TypeError: Cannot read properties of undefined (reading 'type')\n\n    \u001b[0m \u001b[90m 369 |\u001b[39m\n     \u001b[90m 370 |\u001b[39m   \u001b[90m// Handle the event\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 371 |\u001b[39m   \u001b[36mswitch\u001b[39m (event\u001b[33m.\u001b[39mtype) {\n     \u001b[90m     |\u001b[39m                 \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 372 |\u001b[39m     \u001b[36mcase\u001b[39m \u001b[32m'payment_intent.succeeded'\u001b[39m\u001b[33m:\u001b[39m\n     \u001b[90m 373 |\u001b[39m       \u001b[36mconst\u001b[39m paymentIntent \u001b[33m=\u001b[39m event\u001b[33m.\u001b[39mdata\u001b[33m.\u001b[39mobject\u001b[33m;\u001b[39m\n     \u001b[90m 374 |\u001b[39m       \u001b[36mawait\u001b[39m handleSuccessfulPayment(paymentIntent)\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.type [as handleWebhook] (controllers/paymentController.js:371:17)\n      at Object.handleWebhook (tests/unit/controllers/paymentController.test.js:396:31)\n\n  ● PaymentController › handleWebhook › deve lidar com webhook de pagamento falho\n\n    TypeError: Cannot read properties of undefined (reading 'type')\n\n    \u001b[0m \u001b[90m 369 |\u001b[39m\n     \u001b[90m 370 |\u001b[39m   \u001b[90m// Handle the event\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 371 |\u001b[39m   \u001b[36mswitch\u001b[39m (event\u001b[33m.\u001b[39mtype) {\n     \u001b[90m     |\u001b[39m                 \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 372 |\u001b[39m     \u001b[36mcase\u001b[39m \u001b[32m'payment_intent.succeeded'\u001b[39m\u001b[33m:\u001b[39m\n     \u001b[90m 373 |\u001b[39m       \u001b[36mconst\u001b[39m paymentIntent \u001b[33m=\u001b[39m event\u001b[33m.\u001b[39mdata\u001b[33m.\u001b[39mobject\u001b[33m;\u001b[39m\n     \u001b[90m 374 |\u001b[39m       \u001b[36mawait\u001b[39m handleSuccessfulPayment(paymentIntent)\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.type [as handleWebhook] (controllers/paymentController.js:371:17)\n      at Object.handleWebhook (tests/unit/controllers/paymentController.test.js:424:31)\n\n  ● PaymentController › getTransactionHistory › deve retornar histórico de transações do usuário\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"order\": [[\"createdAt\", \"DESC\"]], \"where\": {\"userId\": 1}}\n    Received: {\"order\": [[\"createdAt\", \"DESC\"]], \"where\": {\"status\": {Symbol(in): [\"completed\", \"failed\", \"refunded\"]}, \"userId\": 1}}\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m 460 |\u001b[39m\n     \u001b[90m 461 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 462 |\u001b[39m       expect(\u001b[33mTransaction\u001b[39m\u001b[33m.\u001b[39mfindAll)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m     |\u001b[39m                                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 463 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 464 |\u001b[39m           where\u001b[33m:\u001b[39m { userId\u001b[33m:\u001b[39m \u001b[35m1\u001b[39m }\u001b[33m,\u001b[39m\n     \u001b[90m 465 |\u001b[39m           order\u001b[33m:\u001b[39m [[\u001b[32m'createdAt'\u001b[39m\u001b[33m,\u001b[39m \u001b[32m'DESC'\u001b[39m]]\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/paymentController.test.js:462:35)\n\n  ● PaymentController › getTransactionHistory › deve retornar lista vazia quando usuário não tem transações\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"success\": true, \"transactions\": []}\n    Received: []\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m 482 |\u001b[39m\n     \u001b[90m 483 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 484 |\u001b[39m       expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 485 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 486 |\u001b[39m           success\u001b[33m:\u001b[39m \u001b[36mtrue\u001b[39m\u001b[33m,\u001b[39m\n     \u001b[90m 487 |\u001b[39m           transactions\u001b[33m:\u001b[39m []\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/paymentController.test.js:484:24)\n\nTest Suites: 1 failed, 1 total\nTests:       16 failed, 2 passed, 18 total\nSnapshots:   0 total\nTime:        1.285 s, estimated 3 s\n"
    },
    {
      "file": "tests/unit/controllers/atsController.test.js",
      "status": "FAILED",
      "error": "Command failed: npx jest \"tests/unit/controllers/atsController.test.js\" --verbose --no-coverage --silent\nFAIL tests/unit/controllers/atsController.test.js\n  ATS Controller\n    analyze\n      × deve realizar análise com sucesso (2 ms)\n      √ deve retornar erro quando usuário não está autenticado (3 ms)\n      × deve retornar erro quando usuário não é encontrado (5 ms)\n      × deve retornar erro quando usuário não tem créditos (1 ms)\n      × deve retornar erro quando arquivo não é fornecido\n      × deve retornar erro quando links de vagas não são fornecidos\n      × deve retornar erro quando menos de 3 vagas são fornecidas\n      × deve retornar erro quando mais de 7 vagas são fornecidas (1 ms)\n      × deve tratar erros do serviço de análise (1 ms)\n      × deve lidar com JSON inválido nos jobLinks\n      × deve salvar resultados da análise no banco\n      √ deve processar análise mesmo com créditos nulos (1 ms)\n    getAnalysisHistory\n      × deve retornar histórico de análises do usuário (2 ms)\n      × deve retornar lista vazia quando usuário não tem análises\n      √ deve tratar erros ao buscar histórico (1 ms)\n    getAnalysisById\n      × deve retornar análise específica do usuário (4 ms)\n      √ deve retornar erro quando análise não é encontrada (1 ms)\n      √ deve tratar IDs inválidos\n\n  ● ATS Controller › analyze › deve realizar análise com sucesso\n\n    TypeError: Cannot read properties of undefined (reading 'mockResolvedValue')\n\n    \u001b[0m \u001b[90m 75 |\u001b[39m     it(\u001b[32m'deve realizar análise com sucesso'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\n     \u001b[90m 76 |\u001b[39m       \u001b[90m// Arrange\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 77 |\u001b[39m       atsService\u001b[33m.\u001b[39manalyzeResumeWithJobs\u001b[33m.\u001b[39mmockResolvedValue(mockAnalysisResult)\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 78 |\u001b[39m       \n     \u001b[90m 79 |\u001b[39m       \u001b[36mconst\u001b[39m mockUserInstance \u001b[33m=\u001b[39m {\n     \u001b[90m 80 |\u001b[39m         \u001b[33m...\u001b[39mmockUser\u001b[33m,\u001b[39m\u001b[0m\n\n      at Object.mockResolvedValue (tests/unit/controllers/atsController.test.js:77:40)\n\n  ● ATS Controller › analyze › deve retornar erro quando usuário não é encontrado\n\n    expect(received).not.toHaveBeenCalled()\n\n    Matcher error: received value must be a mock or spy function\n\n    Received has value: undefined\n\n    \u001b[0m \u001b[90m 139 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n     \u001b[90m 140 |\u001b[39m       expectErrorResponse(res\u001b[33m,\u001b[39m \u001b[35m404\u001b[39m\u001b[33m,\u001b[39m \u001b[32m'Usuário não encontrado'\u001b[39m)\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 141 |\u001b[39m       expect(atsService\u001b[33m.\u001b[39manalyzeResumeWithJobs)\u001b[33m.\u001b[39mnot\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                                    \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 142 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 143 |\u001b[39m\n     \u001b[90m 144 |\u001b[39m     it(\u001b[32m'deve retornar erro quando usuário não tem créditos'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.toHaveBeenCalled (tests/unit/controllers/atsController.test.js:141:52)\n\n  ● ATS Controller › analyze › deve retornar erro quando usuário não tem créditos\n\n    expect(received).not.toHaveBeenCalled()\n\n    Matcher error: received value must be a mock or spy function\n\n    Received has value: undefined\n\n    \u001b[0m \u001b[90m 156 |\u001b[39m       \u001b[36mconst\u001b[39m jsonCall \u001b[33m=\u001b[39m res\u001b[33m.\u001b[39mjson\u001b[33m.\u001b[39mmock\u001b[33m.\u001b[39mcalls[\u001b[35m0\u001b[39m][\u001b[35m0\u001b[39m]\u001b[33m;\u001b[39m\n     \u001b[90m 157 |\u001b[39m       expect(jsonCall\u001b[33m.\u001b[39mcredits)\u001b[33m.\u001b[39mtoBe(\u001b[35m0\u001b[39m)\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 158 |\u001b[39m       expect(atsService\u001b[33m.\u001b[39manalyzeResumeWithJobs)\u001b[33m.\u001b[39mnot\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                                    \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 159 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 160 |\u001b[39m\n     \u001b[90m 161 |\u001b[39m     it(\u001b[32m'deve retornar erro quando arquivo não é fornecido'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.toHaveBeenCalled (tests/unit/controllers/atsController.test.js:158:52)\n\n  ● ATS Controller › analyze › deve retornar erro quando arquivo não é fornecido\n\n    expect(received).toContain(expected) // indexOf\n\n    Expected substring: \"arquivo ou links ausentes\"\n    Received string:    \"Arquivo de currículo ou links de vagas ausentes.\"\n\n    \u001b[0m \u001b[90m 106 |\u001b[39m         expect(jsonCall\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoBeDefined()\u001b[33m;\u001b[39m\n     \u001b[90m 107 |\u001b[39m         \u001b[36mif\u001b[39m (\u001b[36mtypeof\u001b[39m expectedMessage \u001b[33m===\u001b[39m \u001b[32m'string'\u001b[39m) {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 108 |\u001b[39m             expect(jsonCall\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(expectedMessage)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                    \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 109 |\u001b[39m         }\n     \u001b[90m 110 |\u001b[39m     }\n     \u001b[90m 111 |\u001b[39m }\u001b[33m;\u001b[39m\u001b[0m\n\n      at toContain (tests/helpers/testHelpers.js:108:36)\n      at Object.expectErrorResponse (tests/unit/controllers/atsController.test.js:169:7)\n\n  ● ATS Controller › analyze › deve retornar erro quando links de vagas não são fornecidos\n\n    expect(received).toContain(expected) // indexOf\n\n    Expected substring: \"arquivo ou links ausentes\"\n    Received string:    \"Arquivo de currículo ou links de vagas ausentes.\"\n\n    \u001b[0m \u001b[90m 106 |\u001b[39m         expect(jsonCall\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoBeDefined()\u001b[33m;\u001b[39m\n     \u001b[90m 107 |\u001b[39m         \u001b[36mif\u001b[39m (\u001b[36mtypeof\u001b[39m expectedMessage \u001b[33m===\u001b[39m \u001b[32m'string'\u001b[39m) {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 108 |\u001b[39m             expect(jsonCall\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(expectedMessage)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                    \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 109 |\u001b[39m         }\n     \u001b[90m 110 |\u001b[39m     }\n     \u001b[90m 111 |\u001b[39m }\u001b[33m;\u001b[39m\u001b[0m\n\n      at toContain (tests/helpers/testHelpers.js:108:36)\n      at Object.expectErrorResponse (tests/unit/controllers/atsController.test.js:181:7)\n\n  ● ATS Controller › analyze › deve retornar erro quando menos de 3 vagas são fornecidas\n\n    expect(received).not.toHaveBeenCalled()\n\n    Matcher error: received value must be a mock or spy function\n\n    Received has value: undefined\n\n    \u001b[0m \u001b[90m 195 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n     \u001b[90m 196 |\u001b[39m       expectErrorResponse(res\u001b[33m,\u001b[39m \u001b[35m400\u001b[39m\u001b[33m,\u001b[39m \u001b[32m'pelo menos 3 vagas'\u001b[39m)\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 197 |\u001b[39m       expect(atsService\u001b[33m.\u001b[39manalyzeResumeWithJobs)\u001b[33m.\u001b[39mnot\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                                    \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 198 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 199 |\u001b[39m\n     \u001b[90m 200 |\u001b[39m     it(\u001b[32m'deve retornar erro quando mais de 7 vagas são fornecidas'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.toHaveBeenCalled (tests/unit/controllers/atsController.test.js:197:52)\n\n  ● ATS Controller › analyze › deve retornar erro quando mais de 7 vagas são fornecidas\n\n    expect(received).not.toHaveBeenCalled()\n\n    Matcher error: received value must be a mock or spy function\n\n    Received has value: undefined\n\n    \u001b[0m \u001b[90m 208 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n     \u001b[90m 209 |\u001b[39m       expectErrorResponse(res\u001b[33m,\u001b[39m \u001b[35m400\u001b[39m\u001b[33m,\u001b[39m \u001b[32m'limite máximo é de 7 vagas'\u001b[39m)\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 210 |\u001b[39m       expect(atsService\u001b[33m.\u001b[39manalyzeResumeWithJobs)\u001b[33m.\u001b[39mnot\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                                    \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 211 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 212 |\u001b[39m\n     \u001b[90m 213 |\u001b[39m     it(\u001b[32m'deve tratar erros do serviço de análise'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.toHaveBeenCalled (tests/unit/controllers/atsController.test.js:210:52)\n\n  ● ATS Controller › analyze › deve tratar erros do serviço de análise\n\n    TypeError: Cannot read properties of undefined (reading 'mockRejectedValue')\n\n    \u001b[0m \u001b[90m 213 |\u001b[39m     it(\u001b[32m'deve tratar erros do serviço de análise'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\n     \u001b[90m 214 |\u001b[39m       \u001b[90m// Arrange\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 215 |\u001b[39m       atsService\u001b[33m.\u001b[39manalyzeResumeWithJobs\u001b[33m.\u001b[39mmockRejectedValue(\n     \u001b[90m     |\u001b[39m                                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 216 |\u001b[39m         \u001b[36mnew\u001b[39m \u001b[33mError\u001b[39m(\u001b[32m'Erro na análise do OpenAI'\u001b[39m)\n     \u001b[90m 217 |\u001b[39m       )\u001b[33m;\u001b[39m\n     \u001b[90m 218 |\u001b[39m\u001b[0m\n\n      at Object.mockRejectedValue (tests/unit/controllers/atsController.test.js:215:40)\n\n  ● ATS Controller › analyze › deve lidar com JSON inválido nos jobLinks\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: 400\n    Received: 500\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m  99 |\u001b[39m\n     \u001b[90m 100 |\u001b[39m \u001b[36mconst\u001b[39m expectErrorResponse \u001b[33m=\u001b[39m (res\u001b[33m,\u001b[39m expectedStatus\u001b[33m,\u001b[39m expectedMessage \u001b[33m=\u001b[39m \u001b[36mnull\u001b[39m) \u001b[33m=>\u001b[39m {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 101 |\u001b[39m     expect(res\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(expectedStatus)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 102 |\u001b[39m     expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 103 |\u001b[39m\n     \u001b[90m 104 |\u001b[39m     \u001b[36mif\u001b[39m (expectedMessage) {\u001b[0m\n\n      at toHaveBeenCalledWith (tests/helpers/testHelpers.js:101:24)\n      at Object.expectErrorResponse (tests/unit/controllers/atsController.test.js:237:7)\n\n  ● ATS Controller › analyze › deve salvar resultados da análise no banco\n\n    TypeError: Cannot read properties of undefined (reading 'mockResolvedValue')\n\n    \u001b[0m \u001b[90m 241 |\u001b[39m     it(\u001b[32m'deve salvar resultados da análise no banco'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\n     \u001b[90m 242 |\u001b[39m       \u001b[90m// Arrange\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 243 |\u001b[39m       atsService\u001b[33m.\u001b[39manalyzeResumeWithJobs\u001b[33m.\u001b[39mmockResolvedValue(mockAnalysisResult)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 244 |\u001b[39m       \n     \u001b[90m 245 |\u001b[39m       \u001b[36mconst\u001b[39m mockUserInstance \u001b[33m=\u001b[39m {\n     \u001b[90m 246 |\u001b[39m         \u001b[33m...\u001b[39mmockUser\u001b[33m,\u001b[39m\u001b[0m\n\n      at Object.mockResolvedValue (tests/unit/controllers/atsController.test.js:243:40)\n\n  ● ATS Controller › getAnalysisHistory › deve retornar histórico de análises do usuário\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"history\": [{\"createdAt\": 2025-07-31T03:23:00.233Z, \"id\": 1, \"result\": {\"score_geral\": 85}, \"resumePath\": \"/path/to/resume1.pdf\", \"userId\": 1}, {\"createdAt\": 2025-07-31T03:23:00.233Z, \"id\": 2, \"result\": {\"score_geral\": 78}, \"resumePath\": \"/path/to/resume2.pdf\", \"userId\": 1}], \"success\": true}\n    Received: [{\"createdAt\": 2025-07-31T03:23:00.233Z, \"fileName\": undefined, \"id\": 1, \"jobCount\": 0, \"jobUrls\": undefined, \"summary\": {\"hasCompatibilityScores\": false, \"hasEvaluations\": false, \"hasKeywords\": false}}, {\"createdAt\": 2025-07-31T03:23:00.233Z, \"fileName\": undefined, \"id\": 2, \"jobCount\": 0, \"jobUrls\": undefined, \"summary\": {\"hasCompatibilityScores\": false, \"hasEvaluations\": false, \"hasKeywords\": false}}]\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m 328 |\u001b[39m         })\n     \u001b[90m 329 |\u001b[39m       )\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 330 |\u001b[39m       expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 331 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 332 |\u001b[39m           success\u001b[33m:\u001b[39m \u001b[36mtrue\u001b[39m\u001b[33m,\u001b[39m\n     \u001b[90m 333 |\u001b[39m           history\u001b[33m:\u001b[39m mockHistory\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/atsController.test.js:330:24)\n\n  ● ATS Controller › getAnalysisHistory › deve retornar lista vazia quando usuário não tem análises\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"history\": [], \"success\": true}\n    Received: []\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m 344 |\u001b[39m\n     \u001b[90m 345 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 346 |\u001b[39m       expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 347 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 348 |\u001b[39m           success\u001b[33m:\u001b[39m \u001b[36mtrue\u001b[39m\u001b[33m,\u001b[39m\n     \u001b[90m 349 |\u001b[39m           history\u001b[33m:\u001b[39m []\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/atsController.test.js:346:24)\n\n  ● ATS Controller › getAnalysisById › deve retornar análise específica do usuário\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    - Expected\n    + Received\n\n      Object {\n        \"where\": Object {\n    -     \"id\": 123,\n    +     \"id\": \"123\",\n          \"userId\": 1,\n        },\n      },\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m 385 |\u001b[39m\n     \u001b[90m 386 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 387 |\u001b[39m       expect(\u001b[33mAnalysisResults\u001b[39m\u001b[33m.\u001b[39mfindOne)\u001b[33m.\u001b[39mtoHaveBeenCalledWith({\n     \u001b[90m     |\u001b[39m                                       \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 388 |\u001b[39m         where\u001b[33m:\u001b[39m { id\u001b[33m:\u001b[39m \u001b[35m123\u001b[39m\u001b[33m,\u001b[39m userId\u001b[33m:\u001b[39m \u001b[35m1\u001b[39m }\n     \u001b[90m 389 |\u001b[39m       })\u001b[33m;\u001b[39m\n     \u001b[90m 390 |\u001b[39m       expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/atsController.test.js:387:39)\n\nTest Suites: 1 failed, 1 total\nTests:       13 failed, 5 passed, 18 total\nSnapshots:   0 total\nTime:        1.779 s, estimated 4 s\n",
      "stderr": "FAIL tests/unit/controllers/atsController.test.js\n  ATS Controller\n    analyze\n      × deve realizar análise com sucesso (2 ms)\n      √ deve retornar erro quando usuário não está autenticado (3 ms)\n      × deve retornar erro quando usuário não é encontrado (5 ms)\n      × deve retornar erro quando usuário não tem créditos (1 ms)\n      × deve retornar erro quando arquivo não é fornecido\n      × deve retornar erro quando links de vagas não são fornecidos\n      × deve retornar erro quando menos de 3 vagas são fornecidas\n      × deve retornar erro quando mais de 7 vagas são fornecidas (1 ms)\n      × deve tratar erros do serviço de análise (1 ms)\n      × deve lidar com JSON inválido nos jobLinks\n      × deve salvar resultados da análise no banco\n      √ deve processar análise mesmo com créditos nulos (1 ms)\n    getAnalysisHistory\n      × deve retornar histórico de análises do usuário (2 ms)\n      × deve retornar lista vazia quando usuário não tem análises\n      √ deve tratar erros ao buscar histórico (1 ms)\n    getAnalysisById\n      × deve retornar análise específica do usuário (4 ms)\n      √ deve retornar erro quando análise não é encontrada (1 ms)\n      √ deve tratar IDs inválidos\n\n  ● ATS Controller › analyze › deve realizar análise com sucesso\n\n    TypeError: Cannot read properties of undefined (reading 'mockResolvedValue')\n\n    \u001b[0m \u001b[90m 75 |\u001b[39m     it(\u001b[32m'deve realizar análise com sucesso'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\n     \u001b[90m 76 |\u001b[39m       \u001b[90m// Arrange\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 77 |\u001b[39m       atsService\u001b[33m.\u001b[39manalyzeResumeWithJobs\u001b[33m.\u001b[39mmockResolvedValue(mockAnalysisResult)\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 78 |\u001b[39m       \n     \u001b[90m 79 |\u001b[39m       \u001b[36mconst\u001b[39m mockUserInstance \u001b[33m=\u001b[39m {\n     \u001b[90m 80 |\u001b[39m         \u001b[33m...\u001b[39mmockUser\u001b[33m,\u001b[39m\u001b[0m\n\n      at Object.mockResolvedValue (tests/unit/controllers/atsController.test.js:77:40)\n\n  ● ATS Controller › analyze › deve retornar erro quando usuário não é encontrado\n\n    expect(received).not.toHaveBeenCalled()\n\n    Matcher error: received value must be a mock or spy function\n\n    Received has value: undefined\n\n    \u001b[0m \u001b[90m 139 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n     \u001b[90m 140 |\u001b[39m       expectErrorResponse(res\u001b[33m,\u001b[39m \u001b[35m404\u001b[39m\u001b[33m,\u001b[39m \u001b[32m'Usuário não encontrado'\u001b[39m)\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 141 |\u001b[39m       expect(atsService\u001b[33m.\u001b[39manalyzeResumeWithJobs)\u001b[33m.\u001b[39mnot\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                                    \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 142 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 143 |\u001b[39m\n     \u001b[90m 144 |\u001b[39m     it(\u001b[32m'deve retornar erro quando usuário não tem créditos'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.toHaveBeenCalled (tests/unit/controllers/atsController.test.js:141:52)\n\n  ● ATS Controller › analyze › deve retornar erro quando usuário não tem créditos\n\n    expect(received).not.toHaveBeenCalled()\n\n    Matcher error: received value must be a mock or spy function\n\n    Received has value: undefined\n\n    \u001b[0m \u001b[90m 156 |\u001b[39m       \u001b[36mconst\u001b[39m jsonCall \u001b[33m=\u001b[39m res\u001b[33m.\u001b[39mjson\u001b[33m.\u001b[39mmock\u001b[33m.\u001b[39mcalls[\u001b[35m0\u001b[39m][\u001b[35m0\u001b[39m]\u001b[33m;\u001b[39m\n     \u001b[90m 157 |\u001b[39m       expect(jsonCall\u001b[33m.\u001b[39mcredits)\u001b[33m.\u001b[39mtoBe(\u001b[35m0\u001b[39m)\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 158 |\u001b[39m       expect(atsService\u001b[33m.\u001b[39manalyzeResumeWithJobs)\u001b[33m.\u001b[39mnot\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                                    \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 159 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 160 |\u001b[39m\n     \u001b[90m 161 |\u001b[39m     it(\u001b[32m'deve retornar erro quando arquivo não é fornecido'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.toHaveBeenCalled (tests/unit/controllers/atsController.test.js:158:52)\n\n  ● ATS Controller › analyze › deve retornar erro quando arquivo não é fornecido\n\n    expect(received).toContain(expected) // indexOf\n\n    Expected substring: \"arquivo ou links ausentes\"\n    Received string:    \"Arquivo de currículo ou links de vagas ausentes.\"\n\n    \u001b[0m \u001b[90m 106 |\u001b[39m         expect(jsonCall\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoBeDefined()\u001b[33m;\u001b[39m\n     \u001b[90m 107 |\u001b[39m         \u001b[36mif\u001b[39m (\u001b[36mtypeof\u001b[39m expectedMessage \u001b[33m===\u001b[39m \u001b[32m'string'\u001b[39m) {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 108 |\u001b[39m             expect(jsonCall\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(expectedMessage)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                    \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 109 |\u001b[39m         }\n     \u001b[90m 110 |\u001b[39m     }\n     \u001b[90m 111 |\u001b[39m }\u001b[33m;\u001b[39m\u001b[0m\n\n      at toContain (tests/helpers/testHelpers.js:108:36)\n      at Object.expectErrorResponse (tests/unit/controllers/atsController.test.js:169:7)\n\n  ● ATS Controller › analyze › deve retornar erro quando links de vagas não são fornecidos\n\n    expect(received).toContain(expected) // indexOf\n\n    Expected substring: \"arquivo ou links ausentes\"\n    Received string:    \"Arquivo de currículo ou links de vagas ausentes.\"\n\n    \u001b[0m \u001b[90m 106 |\u001b[39m         expect(jsonCall\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoBeDefined()\u001b[33m;\u001b[39m\n     \u001b[90m 107 |\u001b[39m         \u001b[36mif\u001b[39m (\u001b[36mtypeof\u001b[39m expectedMessage \u001b[33m===\u001b[39m \u001b[32m'string'\u001b[39m) {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 108 |\u001b[39m             expect(jsonCall\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(expectedMessage)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                    \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 109 |\u001b[39m         }\n     \u001b[90m 110 |\u001b[39m     }\n     \u001b[90m 111 |\u001b[39m }\u001b[33m;\u001b[39m\u001b[0m\n\n      at toContain (tests/helpers/testHelpers.js:108:36)\n      at Object.expectErrorResponse (tests/unit/controllers/atsController.test.js:181:7)\n\n  ● ATS Controller › analyze › deve retornar erro quando menos de 3 vagas são fornecidas\n\n    expect(received).not.toHaveBeenCalled()\n\n    Matcher error: received value must be a mock or spy function\n\n    Received has value: undefined\n\n    \u001b[0m \u001b[90m 195 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n     \u001b[90m 196 |\u001b[39m       expectErrorResponse(res\u001b[33m,\u001b[39m \u001b[35m400\u001b[39m\u001b[33m,\u001b[39m \u001b[32m'pelo menos 3 vagas'\u001b[39m)\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 197 |\u001b[39m       expect(atsService\u001b[33m.\u001b[39manalyzeResumeWithJobs)\u001b[33m.\u001b[39mnot\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                                    \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 198 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 199 |\u001b[39m\n     \u001b[90m 200 |\u001b[39m     it(\u001b[32m'deve retornar erro quando mais de 7 vagas são fornecidas'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.toHaveBeenCalled (tests/unit/controllers/atsController.test.js:197:52)\n\n  ● ATS Controller › analyze › deve retornar erro quando mais de 7 vagas são fornecidas\n\n    expect(received).not.toHaveBeenCalled()\n\n    Matcher error: received value must be a mock or spy function\n\n    Received has value: undefined\n\n    \u001b[0m \u001b[90m 208 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n     \u001b[90m 209 |\u001b[39m       expectErrorResponse(res\u001b[33m,\u001b[39m \u001b[35m400\u001b[39m\u001b[33m,\u001b[39m \u001b[32m'limite máximo é de 7 vagas'\u001b[39m)\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 210 |\u001b[39m       expect(atsService\u001b[33m.\u001b[39manalyzeResumeWithJobs)\u001b[33m.\u001b[39mnot\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                                    \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 211 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 212 |\u001b[39m\n     \u001b[90m 213 |\u001b[39m     it(\u001b[32m'deve tratar erros do serviço de análise'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.toHaveBeenCalled (tests/unit/controllers/atsController.test.js:210:52)\n\n  ● ATS Controller › analyze › deve tratar erros do serviço de análise\n\n    TypeError: Cannot read properties of undefined (reading 'mockRejectedValue')\n\n    \u001b[0m \u001b[90m 213 |\u001b[39m     it(\u001b[32m'deve tratar erros do serviço de análise'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\n     \u001b[90m 214 |\u001b[39m       \u001b[90m// Arrange\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 215 |\u001b[39m       atsService\u001b[33m.\u001b[39manalyzeResumeWithJobs\u001b[33m.\u001b[39mmockRejectedValue(\n     \u001b[90m     |\u001b[39m                                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 216 |\u001b[39m         \u001b[36mnew\u001b[39m \u001b[33mError\u001b[39m(\u001b[32m'Erro na análise do OpenAI'\u001b[39m)\n     \u001b[90m 217 |\u001b[39m       )\u001b[33m;\u001b[39m\n     \u001b[90m 218 |\u001b[39m\u001b[0m\n\n      at Object.mockRejectedValue (tests/unit/controllers/atsController.test.js:215:40)\n\n  ● ATS Controller › analyze › deve lidar com JSON inválido nos jobLinks\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: 400\n    Received: 500\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m  99 |\u001b[39m\n     \u001b[90m 100 |\u001b[39m \u001b[36mconst\u001b[39m expectErrorResponse \u001b[33m=\u001b[39m (res\u001b[33m,\u001b[39m expectedStatus\u001b[33m,\u001b[39m expectedMessage \u001b[33m=\u001b[39m \u001b[36mnull\u001b[39m) \u001b[33m=>\u001b[39m {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 101 |\u001b[39m     expect(res\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(expectedStatus)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 102 |\u001b[39m     expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 103 |\u001b[39m\n     \u001b[90m 104 |\u001b[39m     \u001b[36mif\u001b[39m (expectedMessage) {\u001b[0m\n\n      at toHaveBeenCalledWith (tests/helpers/testHelpers.js:101:24)\n      at Object.expectErrorResponse (tests/unit/controllers/atsController.test.js:237:7)\n\n  ● ATS Controller › analyze › deve salvar resultados da análise no banco\n\n    TypeError: Cannot read properties of undefined (reading 'mockResolvedValue')\n\n    \u001b[0m \u001b[90m 241 |\u001b[39m     it(\u001b[32m'deve salvar resultados da análise no banco'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\n     \u001b[90m 242 |\u001b[39m       \u001b[90m// Arrange\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 243 |\u001b[39m       atsService\u001b[33m.\u001b[39manalyzeResumeWithJobs\u001b[33m.\u001b[39mmockResolvedValue(mockAnalysisResult)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 244 |\u001b[39m       \n     \u001b[90m 245 |\u001b[39m       \u001b[36mconst\u001b[39m mockUserInstance \u001b[33m=\u001b[39m {\n     \u001b[90m 246 |\u001b[39m         \u001b[33m...\u001b[39mmockUser\u001b[33m,\u001b[39m\u001b[0m\n\n      at Object.mockResolvedValue (tests/unit/controllers/atsController.test.js:243:40)\n\n  ● ATS Controller › getAnalysisHistory › deve retornar histórico de análises do usuário\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"history\": [{\"createdAt\": 2025-07-31T03:23:00.233Z, \"id\": 1, \"result\": {\"score_geral\": 85}, \"resumePath\": \"/path/to/resume1.pdf\", \"userId\": 1}, {\"createdAt\": 2025-07-31T03:23:00.233Z, \"id\": 2, \"result\": {\"score_geral\": 78}, \"resumePath\": \"/path/to/resume2.pdf\", \"userId\": 1}], \"success\": true}\n    Received: [{\"createdAt\": 2025-07-31T03:23:00.233Z, \"fileName\": undefined, \"id\": 1, \"jobCount\": 0, \"jobUrls\": undefined, \"summary\": {\"hasCompatibilityScores\": false, \"hasEvaluations\": false, \"hasKeywords\": false}}, {\"createdAt\": 2025-07-31T03:23:00.233Z, \"fileName\": undefined, \"id\": 2, \"jobCount\": 0, \"jobUrls\": undefined, \"summary\": {\"hasCompatibilityScores\": false, \"hasEvaluations\": false, \"hasKeywords\": false}}]\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m 328 |\u001b[39m         })\n     \u001b[90m 329 |\u001b[39m       )\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 330 |\u001b[39m       expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 331 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 332 |\u001b[39m           success\u001b[33m:\u001b[39m \u001b[36mtrue\u001b[39m\u001b[33m,\u001b[39m\n     \u001b[90m 333 |\u001b[39m           history\u001b[33m:\u001b[39m mockHistory\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/atsController.test.js:330:24)\n\n  ● ATS Controller › getAnalysisHistory › deve retornar lista vazia quando usuário não tem análises\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: ObjectContaining {\"history\": [], \"success\": true}\n    Received: []\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m 344 |\u001b[39m\n     \u001b[90m 345 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 346 |\u001b[39m       expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m     |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 347 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 348 |\u001b[39m           success\u001b[33m:\u001b[39m \u001b[36mtrue\u001b[39m\u001b[33m,\u001b[39m\n     \u001b[90m 349 |\u001b[39m           history\u001b[33m:\u001b[39m []\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/atsController.test.js:346:24)\n\n  ● ATS Controller › getAnalysisById › deve retornar análise específica do usuário\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    - Expected\n    + Received\n\n      Object {\n        \"where\": Object {\n    -     \"id\": 123,\n    +     \"id\": \"123\",\n          \"userId\": 1,\n        },\n      },\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m 385 |\u001b[39m\n     \u001b[90m 386 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 387 |\u001b[39m       expect(\u001b[33mAnalysisResults\u001b[39m\u001b[33m.\u001b[39mfindOne)\u001b[33m.\u001b[39mtoHaveBeenCalledWith({\n     \u001b[90m     |\u001b[39m                                       \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 388 |\u001b[39m         where\u001b[33m:\u001b[39m { id\u001b[33m:\u001b[39m \u001b[35m123\u001b[39m\u001b[33m,\u001b[39m userId\u001b[33m:\u001b[39m \u001b[35m1\u001b[39m }\n     \u001b[90m 389 |\u001b[39m       })\u001b[33m;\u001b[39m\n     \u001b[90m 390 |\u001b[39m       expect(res\u001b[33m.\u001b[39mjson)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/controllers/atsController.test.js:387:39)\n\nTest Suites: 1 failed, 1 total\nTests:       13 failed, 5 passed, 18 total\nSnapshots:   0 total\nTime:        1.779 s, estimated 4 s\n"
    },
    {
      "file": "tests/unit/services/openaiService.test.js",
      "status": "FAILED",
      "error": "Command failed: npx jest \"tests/unit/services/openaiService.test.js\" --verbose --no-coverage --silent\nFAIL tests/unit/services/openaiService.test.js (8.591 s)\n  OpenAI Service\n    extractATSData\n      √ deve usar Claude quando recomendado pelo rate monitor (5 ms)\n      × deve usar OpenAI quando recomendado pelo rate monitor (2 ms)\n      × deve fazer fallback para Claude quando OpenAI falha com rate limit (1 ms)\n      × deve usar backoff exponencial em retries (1 ms)\n      √ deve tratar erros não retriáveis usando Claude como fallback (1 ms)\n      √ deve processar resposta JSON com blocos de código (1 ms)\n      √ deve lançar erro quando ambos os serviços falham (8104 ms)\n      × deve calcular tokens estimados corretamente\n      √ deve lidar com parâmetros vazios (1 ms)\n      × deve atualizar monitor de rate limit após sucesso (1 ms)\n      √ deve lidar com resposta JSON malformada usando fallback (1 ms)\n\n  ● OpenAI Service › extractATSData › deve usar OpenAI quando recomendado pelo rate monitor\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: Any<Number>\n\n    Number of calls: 0\n\n    \u001b[0m \u001b[90m 113 |\u001b[39m         })\n     \u001b[90m 114 |\u001b[39m       )\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 115 |\u001b[39m       expect(rateLimitMonitor\u001b[33m.\u001b[39mupdateOpenAIUsage)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(expect\u001b[33m.\u001b[39many(\u001b[33mNumber\u001b[39m))\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                                  \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 116 |\u001b[39m       expect(result)\u001b[33m.\u001b[39mtoEqual(mockAnalysisResponse)\u001b[33m;\u001b[39m\n     \u001b[90m 117 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 118 |\u001b[39m\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/services/openaiService.test.js:115:50)\n\n  ● OpenAI Service › extractATSData › deve fazer fallback para Claude quando OpenAI falha com rate limit\n\n    TypeError: rateLimitMonitor.getOpenAIWaitTime is not a function\n\n    \u001b[0m \u001b[90m 341 |\u001b[39m       \u001b[90m// Para erro 429, usar um delay maior ou baseado no reset time\u001b[39m\n     \u001b[90m 342 |\u001b[39m       \u001b[36mif\u001b[39m (error\u001b[33m.\u001b[39mresponse \u001b[33m&&\u001b[39m error\u001b[33m.\u001b[39mresponse\u001b[33m.\u001b[39mstatus \u001b[33m===\u001b[39m \u001b[35m429\u001b[39m) {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 343 |\u001b[39m         \u001b[36mconst\u001b[39m waitTime \u001b[33m=\u001b[39m rateLimitMonitor\u001b[33m.\u001b[39mgetOpenAIWaitTime()\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                           \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 344 |\u001b[39m         delay \u001b[33m=\u001b[39m \u001b[33mMath\u001b[39m\u001b[33m.\u001b[39mmax(delay\u001b[33m,\u001b[39m waitTime)\u001b[33m;\u001b[39m\n     \u001b[90m 345 |\u001b[39m       }\n     \u001b[90m 346 |\u001b[39m\u001b[0m\n\n      at Object.getOpenAIWaitTime [as extractATSData] (services/openaiService.js:343:43)\n      at Object.<anonymous> (tests/unit/services/openaiService.test.js:137:22)\n\n  ● OpenAI Service › extractATSData › deve usar backoff exponencial em retries\n\n    TypeError: rateLimitMonitor.getOpenAIWaitTime is not a function\n\n    \u001b[0m \u001b[90m 341 |\u001b[39m       \u001b[90m// Para erro 429, usar um delay maior ou baseado no reset time\u001b[39m\n     \u001b[90m 342 |\u001b[39m       \u001b[36mif\u001b[39m (error\u001b[33m.\u001b[39mresponse \u001b[33m&&\u001b[39m error\u001b[33m.\u001b[39mresponse\u001b[33m.\u001b[39mstatus \u001b[33m===\u001b[39m \u001b[35m429\u001b[39m) {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 343 |\u001b[39m         \u001b[36mconst\u001b[39m waitTime \u001b[33m=\u001b[39m rateLimitMonitor\u001b[33m.\u001b[39mgetOpenAIWaitTime()\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                           \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 344 |\u001b[39m         delay \u001b[33m=\u001b[39m \u001b[33mMath\u001b[39m\u001b[33m.\u001b[39mmax(delay\u001b[33m,\u001b[39m waitTime)\u001b[33m;\u001b[39m\n     \u001b[90m 345 |\u001b[39m       }\n     \u001b[90m 346 |\u001b[39m\u001b[0m\n\n      at Object.getOpenAIWaitTime [as extractATSData] (services/openaiService.js:343:43)\n      at Object.<anonymous> (tests/unit/services/openaiService.test.js:169:22)\n\n  ● OpenAI Service › extractATSData › deve calcular tokens estimados corretamente\n\n    Ambos os serviços falharam. OpenAI: Rate limit. Claude: Claude failed\n\n    \u001b[0m \u001b[90m 372 |\u001b[39m   } \u001b[36mcatch\u001b[39m (errClaude) {\n     \u001b[90m 373 |\u001b[39m     console\u001b[33m.\u001b[39merror(\u001b[32m'[Claude] Fallback também falhou:'\u001b[39m\u001b[33m,\u001b[39m errClaude\u001b[33m.\u001b[39mmessage)\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 374 |\u001b[39m     \u001b[36mthrow\u001b[39m \u001b[36mnew\u001b[39m \u001b[33mError\u001b[39m(\u001b[32m`Ambos os serviços falharam. OpenAI: Rate limit. Claude: ${errClaude.message}`\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m           \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 375 |\u001b[39m   }\n     \u001b[90m 376 |\u001b[39m }\u001b[33m;\u001b[39m\n     \u001b[90m 377 |\u001b[39m\u001b[0m\n\n      at Object.<anonymous>.exports.extractATSData (services/openaiService.js:374:11)\n      at Object.<anonymous> (tests/unit/services/openaiService.test.js:261:7)\n\n  ● OpenAI Service › extractATSData › deve atualizar monitor de rate limit após sucesso\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: Any<Number>\n\n    Number of calls: 0\n\n    \u001b[0m \u001b[90m 304 |\u001b[39m\n     \u001b[90m 305 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 306 |\u001b[39m       expect(rateLimitMonitor\u001b[33m.\u001b[39mupdateOpenAIUsage)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m     |\u001b[39m                                                  \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 307 |\u001b[39m         expect\u001b[33m.\u001b[39many(\u001b[33mNumber\u001b[39m) \u001b[90m// Tokens estimados\u001b[39m\n     \u001b[90m 308 |\u001b[39m       )\u001b[33m;\u001b[39m\n     \u001b[90m 309 |\u001b[39m     })\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/services/openaiService.test.js:306:50)\n\nTest Suites: 1 failed, 1 total\nTests:       5 failed, 6 passed, 11 total\nSnapshots:   0 total\nTime:        8.651 s, estimated 11 s\n",
      "stderr": "FAIL tests/unit/services/openaiService.test.js (8.591 s)\n  OpenAI Service\n    extractATSData\n      √ deve usar Claude quando recomendado pelo rate monitor (5 ms)\n      × deve usar OpenAI quando recomendado pelo rate monitor (2 ms)\n      × deve fazer fallback para Claude quando OpenAI falha com rate limit (1 ms)\n      × deve usar backoff exponencial em retries (1 ms)\n      √ deve tratar erros não retriáveis usando Claude como fallback (1 ms)\n      √ deve processar resposta JSON com blocos de código (1 ms)\n      √ deve lançar erro quando ambos os serviços falham (8104 ms)\n      × deve calcular tokens estimados corretamente\n      √ deve lidar com parâmetros vazios (1 ms)\n      × deve atualizar monitor de rate limit após sucesso (1 ms)\n      √ deve lidar com resposta JSON malformada usando fallback (1 ms)\n\n  ● OpenAI Service › extractATSData › deve usar OpenAI quando recomendado pelo rate monitor\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: Any<Number>\n\n    Number of calls: 0\n\n    \u001b[0m \u001b[90m 113 |\u001b[39m         })\n     \u001b[90m 114 |\u001b[39m       )\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 115 |\u001b[39m       expect(rateLimitMonitor\u001b[33m.\u001b[39mupdateOpenAIUsage)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(expect\u001b[33m.\u001b[39many(\u001b[33mNumber\u001b[39m))\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                                  \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 116 |\u001b[39m       expect(result)\u001b[33m.\u001b[39mtoEqual(mockAnalysisResponse)\u001b[33m;\u001b[39m\n     \u001b[90m 117 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 118 |\u001b[39m\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/services/openaiService.test.js:115:50)\n\n  ● OpenAI Service › extractATSData › deve fazer fallback para Claude quando OpenAI falha com rate limit\n\n    TypeError: rateLimitMonitor.getOpenAIWaitTime is not a function\n\n    \u001b[0m \u001b[90m 341 |\u001b[39m       \u001b[90m// Para erro 429, usar um delay maior ou baseado no reset time\u001b[39m\n     \u001b[90m 342 |\u001b[39m       \u001b[36mif\u001b[39m (error\u001b[33m.\u001b[39mresponse \u001b[33m&&\u001b[39m error\u001b[33m.\u001b[39mresponse\u001b[33m.\u001b[39mstatus \u001b[33m===\u001b[39m \u001b[35m429\u001b[39m) {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 343 |\u001b[39m         \u001b[36mconst\u001b[39m waitTime \u001b[33m=\u001b[39m rateLimitMonitor\u001b[33m.\u001b[39mgetOpenAIWaitTime()\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                           \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 344 |\u001b[39m         delay \u001b[33m=\u001b[39m \u001b[33mMath\u001b[39m\u001b[33m.\u001b[39mmax(delay\u001b[33m,\u001b[39m waitTime)\u001b[33m;\u001b[39m\n     \u001b[90m 345 |\u001b[39m       }\n     \u001b[90m 346 |\u001b[39m\u001b[0m\n\n      at Object.getOpenAIWaitTime [as extractATSData] (services/openaiService.js:343:43)\n      at Object.<anonymous> (tests/unit/services/openaiService.test.js:137:22)\n\n  ● OpenAI Service › extractATSData › deve usar backoff exponencial em retries\n\n    TypeError: rateLimitMonitor.getOpenAIWaitTime is not a function\n\n    \u001b[0m \u001b[90m 341 |\u001b[39m       \u001b[90m// Para erro 429, usar um delay maior ou baseado no reset time\u001b[39m\n     \u001b[90m 342 |\u001b[39m       \u001b[36mif\u001b[39m (error\u001b[33m.\u001b[39mresponse \u001b[33m&&\u001b[39m error\u001b[33m.\u001b[39mresponse\u001b[33m.\u001b[39mstatus \u001b[33m===\u001b[39m \u001b[35m429\u001b[39m) {\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 343 |\u001b[39m         \u001b[36mconst\u001b[39m waitTime \u001b[33m=\u001b[39m rateLimitMonitor\u001b[33m.\u001b[39mgetOpenAIWaitTime()\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                           \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 344 |\u001b[39m         delay \u001b[33m=\u001b[39m \u001b[33mMath\u001b[39m\u001b[33m.\u001b[39mmax(delay\u001b[33m,\u001b[39m waitTime)\u001b[33m;\u001b[39m\n     \u001b[90m 345 |\u001b[39m       }\n     \u001b[90m 346 |\u001b[39m\u001b[0m\n\n      at Object.getOpenAIWaitTime [as extractATSData] (services/openaiService.js:343:43)\n      at Object.<anonymous> (tests/unit/services/openaiService.test.js:169:22)\n\n  ● OpenAI Service › extractATSData › deve calcular tokens estimados corretamente\n\n    Ambos os serviços falharam. OpenAI: Rate limit. Claude: Claude failed\n\n    \u001b[0m \u001b[90m 372 |\u001b[39m   } \u001b[36mcatch\u001b[39m (errClaude) {\n     \u001b[90m 373 |\u001b[39m     console\u001b[33m.\u001b[39merror(\u001b[32m'[Claude] Fallback também falhou:'\u001b[39m\u001b[33m,\u001b[39m errClaude\u001b[33m.\u001b[39mmessage)\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 374 |\u001b[39m     \u001b[36mthrow\u001b[39m \u001b[36mnew\u001b[39m \u001b[33mError\u001b[39m(\u001b[32m`Ambos os serviços falharam. OpenAI: Rate limit. Claude: ${errClaude.message}`\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m           \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 375 |\u001b[39m   }\n     \u001b[90m 376 |\u001b[39m }\u001b[33m;\u001b[39m\n     \u001b[90m 377 |\u001b[39m\u001b[0m\n\n      at Object.<anonymous>.exports.extractATSData (services/openaiService.js:374:11)\n      at Object.<anonymous> (tests/unit/services/openaiService.test.js:261:7)\n\n  ● OpenAI Service › extractATSData › deve atualizar monitor de rate limit após sucesso\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: Any<Number>\n\n    Number of calls: 0\n\n    \u001b[0m \u001b[90m 304 |\u001b[39m\n     \u001b[90m 305 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 306 |\u001b[39m       expect(rateLimitMonitor\u001b[33m.\u001b[39mupdateOpenAIUsage)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m     |\u001b[39m                                                  \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 307 |\u001b[39m         expect\u001b[33m.\u001b[39many(\u001b[33mNumber\u001b[39m) \u001b[90m// Tokens estimados\u001b[39m\n     \u001b[90m 308 |\u001b[39m       )\u001b[33m;\u001b[39m\n     \u001b[90m 309 |\u001b[39m     })\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/services/openaiService.test.js:306:50)\n\nTest Suites: 1 failed, 1 total\nTests:       5 failed, 6 passed, 11 total\nSnapshots:   0 total\nTime:        8.651 s, estimated 11 s\n"
    },
    {
      "file": "tests/unit/services/emailService.test.js",
      "status": "FAILED",
      "error": "Command failed: npx jest \"tests/unit/services/emailService.test.js\" --verbose --no-coverage --silent\nC:\\Users\\Rafael\\Repository\\backend\\services\\emailService.js:10\r\n    return nodemailer.createTransport({\r\n                      ^\r\n\r\nTypeError: nodemailer.createTransport is not a function\r\n    at createTransport (C:\\Users\\Rafael\\Repository\\backend\\services\\emailService.js:8:23)\r\n    at Object.createTransporter [as sendPasswordResetEmail] (C:\\Users\\Rafael\\Repository\\backend\\services\\emailService.js:33:25)\r\n    at Object.sendPasswordResetEmail (C:\\Users\\Rafael\\Repository\\backend\\tests\\unit\\services\\emailService.test.js:285:20)\r\n    at Promise.then.completed (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\utils.js:298:28)\r\n    at new Promise (<anonymous>)\r\n    at callAsyncCircusFn (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\utils.js:231:10)\r\n    at _callCircusTest (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\run.js:316:40)\r\n    at _runTest (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\run.js:252:3)\r\n    at _runTestsForDescribeBlock (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\run.js:126:9)\r\n    at _runTestsForDescribeBlock (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\run.js:121:9)\r\n    at _runTestsForDescribeBlock (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\run.js:121:9)\r\n    at run (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\run.js:71:3)\r\n    at runAndTransformResultsToJestFormat (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\legacy-code-todo-rewrite\\jestAdapterInit.js:122:21)\r\n    at jestAdapter (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\legacy-code-todo-rewrite\\jestAdapter.js:79:19)\r\n    at runTestInternal (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-runner\\build\\runTest.js:367:16)\r\n    at runTest (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-runner\\build\\runTest.js:444:34)\r\n\r\nNode.js v22.13.0\r\n",
      "stderr": "C:\\Users\\Rafael\\Repository\\backend\\services\\emailService.js:10\r\n    return nodemailer.createTransport({\r\n                      ^\r\n\r\nTypeError: nodemailer.createTransport is not a function\r\n    at createTransport (C:\\Users\\Rafael\\Repository\\backend\\services\\emailService.js:8:23)\r\n    at Object.createTransporter [as sendPasswordResetEmail] (C:\\Users\\Rafael\\Repository\\backend\\services\\emailService.js:33:25)\r\n    at Object.sendPasswordResetEmail (C:\\Users\\Rafael\\Repository\\backend\\tests\\unit\\services\\emailService.test.js:285:20)\r\n    at Promise.then.completed (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\utils.js:298:28)\r\n    at new Promise (<anonymous>)\r\n    at callAsyncCircusFn (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\utils.js:231:10)\r\n    at _callCircusTest (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\run.js:316:40)\r\n    at _runTest (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\run.js:252:3)\r\n    at _runTestsForDescribeBlock (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\run.js:126:9)\r\n    at _runTestsForDescribeBlock (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\run.js:121:9)\r\n    at _runTestsForDescribeBlock (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\run.js:121:9)\r\n    at run (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\run.js:71:3)\r\n    at runAndTransformResultsToJestFormat (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\legacy-code-todo-rewrite\\jestAdapterInit.js:122:21)\r\n    at jestAdapter (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-circus\\build\\legacy-code-todo-rewrite\\jestAdapter.js:79:19)\r\n    at runTestInternal (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-runner\\build\\runTest.js:367:16)\r\n    at runTest (C:\\Users\\Rafael\\Repository\\backend\\node_modules\\jest-runner\\build\\runTest.js:444:34)\r\n\r\nNode.js v22.13.0\r\n"
    },
    {
      "file": "tests/unit/services/claudeService.test.js",
      "status": "FAILED",
      "error": "Command failed: npx jest \"tests/unit/services/claudeService.test.js\" --verbose --no-coverage --silent\nFAIL tests/unit/services/claudeService.test.js\n  Claude Service\n    extractATSDataClaude\n      × deve extrair dados ATS usando Claude com sucesso (5 ms)\n      × deve retornar erro quando API key não está configurada (1 ms)\n      √ deve tratar erro de rate limit do Claude (3 ms)\n      √ deve tratar erro de autenticação do Claude (1 ms)\n      × deve tratar resposta vazia do Claude (11 ms)\n      × deve tratar JSON inválido na resposta do Claude\n      × deve usar configurações corretas da API Claude (2 ms)\n      × deve validar entrada do prompt\n      √ deve tratar timeout da API Claude\n      × deve incluir user-agent correto nas requisições (2 ms)\n\n  ● Claude Service › extractATSDataClaude › deve extrair dados ATS usando Claude com sucesso\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: \"https://api.anthropic.com/v1/messages\", ObjectContaining {\"max_tokens\": 4000, \"messages\": [{\"content\": \"Analise este currículo: João Silva...\", \"role\": \"user\"}], \"model\": \"claude-3-sonnet-20240229\"}, ObjectContaining {\"headers\": ObjectContaining {\"Content-Type\": \"application/json\", \"anthropic-version\": \"2023-06-01\", \"x-api-key\": \"test-claude-key\"}}\n    Received: \"https://api.anthropic.com/v1/messages\", {\"max_tokens\": 8000, \"messages\": [{\"content\": \"Analise este currículo: João Silva...\", \"role\": \"user\"}], \"model\": \"claude-3-7-sonnet-latest\", \"system\": \"Você é um ATS especialista.\", \"temperature\": 0.1}, {\"headers\": {\"anthropic-version\": \"2023-06-01\", \"content-type\": \"application/json\", \"x-api-key\": undefined}}\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m 51 |\u001b[39m\n     \u001b[90m 52 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 53 |\u001b[39m       expect(axios\u001b[33m.\u001b[39mpost)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m    |\u001b[39m                          \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 54 |\u001b[39m         \u001b[32m'https://api.anthropic.com/v1/messages'\u001b[39m\u001b[33m,\u001b[39m\n     \u001b[90m 55 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 56 |\u001b[39m           model\u001b[33m:\u001b[39m \u001b[32m'claude-3-sonnet-20240229'\u001b[39m\u001b[33m,\u001b[39m\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/services/claudeService.test.js:53:26)\n\n  ● Claude Service › extractATSDataClaude › deve retornar erro quando API key não está configurada\n\n    expect(received).rejects.toThrow()\n\n    Received promise resolved instead of rejected\n    Resolved to value: \"{\\\"job_keywords\\\":[\\\"JavaScript\\\",\\\"React\\\",\\\"Node.js\\\"],\\\"job_keywords_present\\\":[\\\"JavaScript\\\"],\\\"job_keywords_missing\\\":[\\\"React\\\",\\\"Node.js\\\"],\\\"sections\\\":{\\\"resumo\\\":{\\\"nota\\\":8,\\\"avaliacao\\\":\\\"Bom resumo profissional\\\",\\\"sugestoes\\\":[\\\"Adicionar objetivos específicos\\\"]}},\\\"score_geral\\\":78}\"\n\n    \u001b[0m \u001b[90m 77 |\u001b[39m\n     \u001b[90m 78 |\u001b[39m       \u001b[90m// Act & Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 79 |\u001b[39m       \u001b[36mawait\u001b[39m expect(claudeService\u001b[33m.\u001b[39mextractATSDataClaude(mockPrompt))\n     \u001b[90m    |\u001b[39m             \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 80 |\u001b[39m         \u001b[33m.\u001b[39mrejects\u001b[33m.\u001b[39mtoThrow(\u001b[32m'Claude API key não configurada'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 81 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 82 |\u001b[39m\u001b[0m\n\n      at expect (node_modules/expect/build/index.js:113:15)\n      at Object.expect (tests/unit/services/claudeService.test.js:79:13)\n\n  ● Claude Service › extractATSDataClaude › deve tratar resposta vazia do Claude\n\n    expect(received).rejects.toThrow(expected)\n\n    Expected substring: \"Resposta vazia do Claude\"\n    Received message:   \"Cannot read properties of undefined (reading 'text')\"\n\n        \u001b[0m \u001b[90m 46 |\u001b[39m     } \u001b[36melse\u001b[39m {\n         \u001b[90m 47 |\u001b[39m       console\u001b[33m.\u001b[39merror(\u001b[32m'[Claude] Error:'\u001b[39m\u001b[33m,\u001b[39m e\u001b[33m.\u001b[39mmessage)\u001b[33m;\u001b[39m\n        \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 48 |\u001b[39m       \u001b[36mthrow\u001b[39m \u001b[36mnew\u001b[39m \u001b[33mError\u001b[39m(e\u001b[33m.\u001b[39mmessage)\u001b[33m;\u001b[39m\n         \u001b[90m    |\u001b[39m             \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n         \u001b[90m 49 |\u001b[39m     }\n         \u001b[90m 50 |\u001b[39m   }\n         \u001b[90m 51 |\u001b[39m }\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.<anonymous>.exports.extractATSDataClaude (services/claudeService.js:48:13)\n      at Object.<anonymous> (tests/unit/services/claudeService.test.js:128:7)\n      at Object.toThrow (node_modules/expect/build/index.js:218:22)\n      at Object.toThrow (tests/unit/services/claudeService.test.js:129:18)\n\n  ● Claude Service › extractATSDataClaude › deve tratar JSON inválido na resposta do Claude\n\n    expect(received).rejects.toThrow()\n\n    Received promise resolved instead of rejected\n    Resolved to value: \"Resposta não é JSON válido\"\n\n    \u001b[0m \u001b[90m 143 |\u001b[39m\n     \u001b[90m 144 |\u001b[39m       \u001b[90m// Act & Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 145 |\u001b[39m       \u001b[36mawait\u001b[39m expect(claudeService\u001b[33m.\u001b[39mextractATSDataClaude(mockPrompt))\n     \u001b[90m     |\u001b[39m             \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 146 |\u001b[39m         \u001b[33m.\u001b[39mrejects\u001b[33m.\u001b[39mtoThrow()\u001b[33m;\u001b[39m\n     \u001b[90m 147 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 148 |\u001b[39m\u001b[0m\n\n      at expect (node_modules/expect/build/index.js:113:15)\n      at Object.expect (tests/unit/services/claudeService.test.js:145:13)\n\n  ● Claude Service › extractATSDataClaude › deve usar configurações corretas da API Claude\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: \"claude-3-sonnet-20240229\"\n    Received: \"claude-3-7-sonnet-latest\"\n\n    \u001b[0m \u001b[90m 167 |\u001b[39m       \n     \u001b[90m 168 |\u001b[39m       expect(url)\u001b[33m.\u001b[39mtoBe(\u001b[32m'https://api.anthropic.com/v1/messages'\u001b[39m)\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 169 |\u001b[39m       expect(requestData\u001b[33m.\u001b[39mmodel)\u001b[33m.\u001b[39mtoBe(\u001b[32m'claude-3-sonnet-20240229'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                 \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 170 |\u001b[39m       expect(requestData\u001b[33m.\u001b[39mmax_tokens)\u001b[33m.\u001b[39mtoBe(\u001b[35m4000\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 171 |\u001b[39m       expect(config\u001b[33m.\u001b[39mheaders[\u001b[32m'x-api-key'\u001b[39m])\u001b[33m.\u001b[39mtoBe(\u001b[32m'test-claude-key'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 172 |\u001b[39m       expect(config\u001b[33m.\u001b[39mheaders[\u001b[32m'anthropic-version'\u001b[39m])\u001b[33m.\u001b[39mtoBe(\u001b[32m'2023-06-01'\u001b[39m)\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/unit/services/claudeService.test.js:169:33)\n\n  ● Claude Service › extractATSDataClaude › deve validar entrada do prompt\n\n    expect(received).rejects.toThrow()\n\n    Received promise resolved instead of rejected\n    Resolved to value: \"{\\\"job_keywords\\\":[\\\"JavaScript\\\",\\\"React\\\",\\\"Node.js\\\"],\\\"job_keywords_present\\\":[\\\"JavaScript\\\"],\\\"job_keywords_missing\\\":[\\\"React\\\",\\\"Node.js\\\"],\\\"sections\\\":{\\\"resumo\\\":{\\\"nota\\\":8,\\\"avaliacao\\\":\\\"Bom resumo profissional\\\",\\\"sugestoes\\\":[\\\"Adicionar objetivos específicos\\\"]}},\\\"score_geral\\\":78}\"\n\n    \u001b[0m \u001b[90m 178 |\u001b[39m\n     \u001b[90m 179 |\u001b[39m       \u001b[90m// Act & Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 180 |\u001b[39m       \u001b[36mawait\u001b[39m expect(claudeService\u001b[33m.\u001b[39mextractATSDataClaude(\u001b[32m''\u001b[39m))\n     \u001b[90m     |\u001b[39m             \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 181 |\u001b[39m         \u001b[33m.\u001b[39mrejects\u001b[33m.\u001b[39mtoThrow(\u001b[32m'Prompt não pode estar vazio'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 182 |\u001b[39m         \n     \u001b[90m 183 |\u001b[39m       \u001b[36mawait\u001b[39m expect(claudeService\u001b[33m.\u001b[39mextractATSDataClaude(\u001b[36mnull\u001b[39m))\u001b[0m\n\n      at expect (node_modules/expect/build/index.js:113:15)\n      at Object.expect (tests/unit/services/claudeService.test.js:180:13)\n\n  ● Claude Service › extractATSDataClaude › deve incluir user-agent correto nas requisições\n\n    expect(received).toEqual(expected) // deep equality\n\n    - Expected  - 2\n    + Received  + 4\n\n    - ObjectContaining {\n    -   \"User-Agent\": StringContaining \"CVSemFrescura\",\n    + Object {\n    +   \"anthropic-version\": \"2023-06-01\",\n    +   \"content-type\": \"application/json\",\n    +   \"x-api-key\": undefined,\n      }\n\n    \u001b[0m \u001b[90m 219 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n     \u001b[90m 220 |\u001b[39m       \u001b[36mconst\u001b[39m config \u001b[33m=\u001b[39m axios\u001b[33m.\u001b[39mpost\u001b[33m.\u001b[39mmock\u001b[33m.\u001b[39mcalls[\u001b[35m0\u001b[39m][\u001b[35m2\u001b[39m]\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 221 |\u001b[39m       expect(config\u001b[33m.\u001b[39mheaders)\u001b[33m.\u001b[39mtoEqual(\n     \u001b[90m     |\u001b[39m                              \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 222 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 223 |\u001b[39m           \u001b[32m'User-Agent'\u001b[39m\u001b[33m:\u001b[39m expect\u001b[33m.\u001b[39mstringContaining(\u001b[32m'CVSemFrescura'\u001b[39m)\n     \u001b[90m 224 |\u001b[39m         })\u001b[0m\n\n      at Object.toEqual (tests/unit/services/claudeService.test.js:221:30)\n\nTest Suites: 1 failed, 1 total\nTests:       7 failed, 3 passed, 10 total\nSnapshots:   0 total\nTime:        0.548 s, estimated 2 s\n",
      "stderr": "FAIL tests/unit/services/claudeService.test.js\n  Claude Service\n    extractATSDataClaude\n      × deve extrair dados ATS usando Claude com sucesso (5 ms)\n      × deve retornar erro quando API key não está configurada (1 ms)\n      √ deve tratar erro de rate limit do Claude (3 ms)\n      √ deve tratar erro de autenticação do Claude (1 ms)\n      × deve tratar resposta vazia do Claude (11 ms)\n      × deve tratar JSON inválido na resposta do Claude\n      × deve usar configurações corretas da API Claude (2 ms)\n      × deve validar entrada do prompt\n      √ deve tratar timeout da API Claude\n      × deve incluir user-agent correto nas requisições (2 ms)\n\n  ● Claude Service › extractATSDataClaude › deve extrair dados ATS usando Claude com sucesso\n\n    expect(jest.fn()).toHaveBeenCalledWith(...expected)\n\n    Expected: \"https://api.anthropic.com/v1/messages\", ObjectContaining {\"max_tokens\": 4000, \"messages\": [{\"content\": \"Analise este currículo: João Silva...\", \"role\": \"user\"}], \"model\": \"claude-3-sonnet-20240229\"}, ObjectContaining {\"headers\": ObjectContaining {\"Content-Type\": \"application/json\", \"anthropic-version\": \"2023-06-01\", \"x-api-key\": \"test-claude-key\"}}\n    Received: \"https://api.anthropic.com/v1/messages\", {\"max_tokens\": 8000, \"messages\": [{\"content\": \"Analise este currículo: João Silva...\", \"role\": \"user\"}], \"model\": \"claude-3-7-sonnet-latest\", \"system\": \"Você é um ATS especialista.\", \"temperature\": 0.1}, {\"headers\": {\"anthropic-version\": \"2023-06-01\", \"content-type\": \"application/json\", \"x-api-key\": undefined}}\n\n    Number of calls: 1\n\n    \u001b[0m \u001b[90m 51 |\u001b[39m\n     \u001b[90m 52 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 53 |\u001b[39m       expect(axios\u001b[33m.\u001b[39mpost)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m    |\u001b[39m                          \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 54 |\u001b[39m         \u001b[32m'https://api.anthropic.com/v1/messages'\u001b[39m\u001b[33m,\u001b[39m\n     \u001b[90m 55 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 56 |\u001b[39m           model\u001b[33m:\u001b[39m \u001b[32m'claude-3-sonnet-20240229'\u001b[39m\u001b[33m,\u001b[39m\u001b[0m\n\n      at Object.toHaveBeenCalledWith (tests/unit/services/claudeService.test.js:53:26)\n\n  ● Claude Service › extractATSDataClaude › deve retornar erro quando API key não está configurada\n\n    expect(received).rejects.toThrow()\n\n    Received promise resolved instead of rejected\n    Resolved to value: \"{\\\"job_keywords\\\":[\\\"JavaScript\\\",\\\"React\\\",\\\"Node.js\\\"],\\\"job_keywords_present\\\":[\\\"JavaScript\\\"],\\\"job_keywords_missing\\\":[\\\"React\\\",\\\"Node.js\\\"],\\\"sections\\\":{\\\"resumo\\\":{\\\"nota\\\":8,\\\"avaliacao\\\":\\\"Bom resumo profissional\\\",\\\"sugestoes\\\":[\\\"Adicionar objetivos específicos\\\"]}},\\\"score_geral\\\":78}\"\n\n    \u001b[0m \u001b[90m 77 |\u001b[39m\n     \u001b[90m 78 |\u001b[39m       \u001b[90m// Act & Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 79 |\u001b[39m       \u001b[36mawait\u001b[39m expect(claudeService\u001b[33m.\u001b[39mextractATSDataClaude(mockPrompt))\n     \u001b[90m    |\u001b[39m             \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 80 |\u001b[39m         \u001b[33m.\u001b[39mrejects\u001b[33m.\u001b[39mtoThrow(\u001b[32m'Claude API key não configurada'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 81 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 82 |\u001b[39m\u001b[0m\n\n      at expect (node_modules/expect/build/index.js:113:15)\n      at Object.expect (tests/unit/services/claudeService.test.js:79:13)\n\n  ● Claude Service › extractATSDataClaude › deve tratar resposta vazia do Claude\n\n    expect(received).rejects.toThrow(expected)\n\n    Expected substring: \"Resposta vazia do Claude\"\n    Received message:   \"Cannot read properties of undefined (reading 'text')\"\n\n        \u001b[0m \u001b[90m 46 |\u001b[39m     } \u001b[36melse\u001b[39m {\n         \u001b[90m 47 |\u001b[39m       console\u001b[33m.\u001b[39merror(\u001b[32m'[Claude] Error:'\u001b[39m\u001b[33m,\u001b[39m e\u001b[33m.\u001b[39mmessage)\u001b[33m;\u001b[39m\n        \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 48 |\u001b[39m       \u001b[36mthrow\u001b[39m \u001b[36mnew\u001b[39m \u001b[33mError\u001b[39m(e\u001b[33m.\u001b[39mmessage)\u001b[33m;\u001b[39m\n         \u001b[90m    |\u001b[39m             \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n         \u001b[90m 49 |\u001b[39m     }\n         \u001b[90m 50 |\u001b[39m   }\n         \u001b[90m 51 |\u001b[39m }\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.<anonymous>.exports.extractATSDataClaude (services/claudeService.js:48:13)\n      at Object.<anonymous> (tests/unit/services/claudeService.test.js:128:7)\n      at Object.toThrow (node_modules/expect/build/index.js:218:22)\n      at Object.toThrow (tests/unit/services/claudeService.test.js:129:18)\n\n  ● Claude Service › extractATSDataClaude › deve tratar JSON inválido na resposta do Claude\n\n    expect(received).rejects.toThrow()\n\n    Received promise resolved instead of rejected\n    Resolved to value: \"Resposta não é JSON válido\"\n\n    \u001b[0m \u001b[90m 143 |\u001b[39m\n     \u001b[90m 144 |\u001b[39m       \u001b[90m// Act & Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 145 |\u001b[39m       \u001b[36mawait\u001b[39m expect(claudeService\u001b[33m.\u001b[39mextractATSDataClaude(mockPrompt))\n     \u001b[90m     |\u001b[39m             \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 146 |\u001b[39m         \u001b[33m.\u001b[39mrejects\u001b[33m.\u001b[39mtoThrow()\u001b[33m;\u001b[39m\n     \u001b[90m 147 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 148 |\u001b[39m\u001b[0m\n\n      at expect (node_modules/expect/build/index.js:113:15)\n      at Object.expect (tests/unit/services/claudeService.test.js:145:13)\n\n  ● Claude Service › extractATSDataClaude › deve usar configurações corretas da API Claude\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: \"claude-3-sonnet-20240229\"\n    Received: \"claude-3-7-sonnet-latest\"\n\n    \u001b[0m \u001b[90m 167 |\u001b[39m       \n     \u001b[90m 168 |\u001b[39m       expect(url)\u001b[33m.\u001b[39mtoBe(\u001b[32m'https://api.anthropic.com/v1/messages'\u001b[39m)\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 169 |\u001b[39m       expect(requestData\u001b[33m.\u001b[39mmodel)\u001b[33m.\u001b[39mtoBe(\u001b[32m'claude-3-sonnet-20240229'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                 \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 170 |\u001b[39m       expect(requestData\u001b[33m.\u001b[39mmax_tokens)\u001b[33m.\u001b[39mtoBe(\u001b[35m4000\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 171 |\u001b[39m       expect(config\u001b[33m.\u001b[39mheaders[\u001b[32m'x-api-key'\u001b[39m])\u001b[33m.\u001b[39mtoBe(\u001b[32m'test-claude-key'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 172 |\u001b[39m       expect(config\u001b[33m.\u001b[39mheaders[\u001b[32m'anthropic-version'\u001b[39m])\u001b[33m.\u001b[39mtoBe(\u001b[32m'2023-06-01'\u001b[39m)\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/unit/services/claudeService.test.js:169:33)\n\n  ● Claude Service › extractATSDataClaude › deve validar entrada do prompt\n\n    expect(received).rejects.toThrow()\n\n    Received promise resolved instead of rejected\n    Resolved to value: \"{\\\"job_keywords\\\":[\\\"JavaScript\\\",\\\"React\\\",\\\"Node.js\\\"],\\\"job_keywords_present\\\":[\\\"JavaScript\\\"],\\\"job_keywords_missing\\\":[\\\"React\\\",\\\"Node.js\\\"],\\\"sections\\\":{\\\"resumo\\\":{\\\"nota\\\":8,\\\"avaliacao\\\":\\\"Bom resumo profissional\\\",\\\"sugestoes\\\":[\\\"Adicionar objetivos específicos\\\"]}},\\\"score_geral\\\":78}\"\n\n    \u001b[0m \u001b[90m 178 |\u001b[39m\n     \u001b[90m 179 |\u001b[39m       \u001b[90m// Act & Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 180 |\u001b[39m       \u001b[36mawait\u001b[39m expect(claudeService\u001b[33m.\u001b[39mextractATSDataClaude(\u001b[32m''\u001b[39m))\n     \u001b[90m     |\u001b[39m             \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 181 |\u001b[39m         \u001b[33m.\u001b[39mrejects\u001b[33m.\u001b[39mtoThrow(\u001b[32m'Prompt não pode estar vazio'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 182 |\u001b[39m         \n     \u001b[90m 183 |\u001b[39m       \u001b[36mawait\u001b[39m expect(claudeService\u001b[33m.\u001b[39mextractATSDataClaude(\u001b[36mnull\u001b[39m))\u001b[0m\n\n      at expect (node_modules/expect/build/index.js:113:15)\n      at Object.expect (tests/unit/services/claudeService.test.js:180:13)\n\n  ● Claude Service › extractATSDataClaude › deve incluir user-agent correto nas requisições\n\n    expect(received).toEqual(expected) // deep equality\n\n    - Expected  - 2\n    + Received  + 4\n\n    - ObjectContaining {\n    -   \"User-Agent\": StringContaining \"CVSemFrescura\",\n    + Object {\n    +   \"anthropic-version\": \"2023-06-01\",\n    +   \"content-type\": \"application/json\",\n    +   \"x-api-key\": undefined,\n      }\n\n    \u001b[0m \u001b[90m 219 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n     \u001b[90m 220 |\u001b[39m       \u001b[36mconst\u001b[39m config \u001b[33m=\u001b[39m axios\u001b[33m.\u001b[39mpost\u001b[33m.\u001b[39mmock\u001b[33m.\u001b[39mcalls[\u001b[35m0\u001b[39m][\u001b[35m2\u001b[39m]\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 221 |\u001b[39m       expect(config\u001b[33m.\u001b[39mheaders)\u001b[33m.\u001b[39mtoEqual(\n     \u001b[90m     |\u001b[39m                              \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 222 |\u001b[39m         expect\u001b[33m.\u001b[39mobjectContaining({\n     \u001b[90m 223 |\u001b[39m           \u001b[32m'User-Agent'\u001b[39m\u001b[33m:\u001b[39m expect\u001b[33m.\u001b[39mstringContaining(\u001b[32m'CVSemFrescura'\u001b[39m)\n     \u001b[90m 224 |\u001b[39m         })\u001b[0m\n\n      at Object.toEqual (tests/unit/services/claudeService.test.js:221:30)\n\nTest Suites: 1 failed, 1 total\nTests:       7 failed, 3 passed, 10 total\nSnapshots:   0 total\nTime:        0.548 s, estimated 2 s\n"
    },
    {
      "file": "tests/unit/services/rateLimitMonitor.test.js",
      "status": "FAILED",
      "error": "Command failed: npx jest \"tests/unit/services/rateLimitMonitor.test.js\" --verbose --no-coverage --silent\nFAIL tests/unit/services/rateLimitMonitor.test.js\n  Rate Limit Monitor\n    getRecommendedService\n      × deve recomendar OpenAI quando dentro dos limites (1 ms)\n      × deve recomendar Claude quando OpenAI está próximo do limite (1 ms)\n      × deve recomendar Claude para requests muito grandes (1 ms)\n      × deve considerar janela de tempo para rate limiting\n    updateOpenAIUsage\n      × deve atualizar estatísticas de uso do OpenAI\n      × deve acumular múltiplas chamadas (1 ms)\n      × deve validar entrada de tokens\n    updateClaudeUsage\n      × deve atualizar estatísticas de uso do Claude\n      × deve acumular múltiplas chamadas do Claude (1 ms)\n    getUsageStats\n      × deve retornar estatísticas vazias inicialmente\n      × deve retornar estatísticas corretas após uso\n      × deve incluir limites configurados\n      × deve calcular tempo até reset (1 ms)\n    checkRateLimit\n      × deve permitir request quando dentro dos limites (1 ms)\n      × deve negar request quando excede limite (1 ms)\n      × deve validar parâmetros de entrada\n    resetStats\n      × deve resetar todas as estatísticas\n    getHealthStatus\n      × deve retornar status saudável quando tudo OK\n      × deve detectar quando OpenAI está próximo do limite\n      × deve detectar quando serviço está no limite\n\n  ● Rate Limit Monitor › getRecommendedService › deve recomendar OpenAI quando dentro dos limites\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getRecommendedService › deve recomendar OpenAI quando dentro dos limites\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getRecommendedService › deve recomendar Claude quando OpenAI está próximo do limite\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getRecommendedService › deve recomendar Claude quando OpenAI está próximo do limite\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getRecommendedService › deve recomendar Claude para requests muito grandes\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getRecommendedService › deve recomendar Claude para requests muito grandes\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getRecommendedService › deve considerar janela de tempo para rate limiting\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getRecommendedService › deve considerar janela de tempo para rate limiting\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › updateOpenAIUsage › deve atualizar estatísticas de uso do OpenAI\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › updateOpenAIUsage › deve atualizar estatísticas de uso do OpenAI\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › updateOpenAIUsage › deve acumular múltiplas chamadas\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › updateOpenAIUsage › deve acumular múltiplas chamadas\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › updateOpenAIUsage › deve validar entrada de tokens\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › updateOpenAIUsage › deve validar entrada de tokens\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › updateClaudeUsage › deve atualizar estatísticas de uso do Claude\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › updateClaudeUsage › deve atualizar estatísticas de uso do Claude\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › updateClaudeUsage › deve acumular múltiplas chamadas do Claude\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › updateClaudeUsage › deve acumular múltiplas chamadas do Claude\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getUsageStats › deve retornar estatísticas vazias inicialmente\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getUsageStats › deve retornar estatísticas vazias inicialmente\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getUsageStats › deve retornar estatísticas corretas após uso\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getUsageStats › deve retornar estatísticas corretas após uso\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getUsageStats › deve incluir limites configurados\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getUsageStats › deve incluir limites configurados\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getUsageStats › deve calcular tempo até reset\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getUsageStats › deve calcular tempo até reset\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › checkRateLimit › deve permitir request quando dentro dos limites\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › checkRateLimit › deve permitir request quando dentro dos limites\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › checkRateLimit › deve negar request quando excede limite\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › checkRateLimit › deve negar request quando excede limite\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › checkRateLimit › deve validar parâmetros de entrada\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › checkRateLimit › deve validar parâmetros de entrada\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › resetStats › deve resetar todas as estatísticas\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › resetStats › deve resetar todas as estatísticas\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getHealthStatus › deve retornar status saudável quando tudo OK\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getHealthStatus › deve retornar status saudável quando tudo OK\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getHealthStatus › deve detectar quando OpenAI está próximo do limite\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getHealthStatus › deve detectar quando OpenAI está próximo do limite\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getHealthStatus › deve detectar quando serviço está no limite\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getHealthStatus › deve detectar quando serviço está no limite\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\nTest Suites: 1 failed, 1 total\nTests:       20 failed, 20 total\nSnapshots:   0 total\nTime:        0.498 s, estimated 2 s\n",
      "stderr": "FAIL tests/unit/services/rateLimitMonitor.test.js\n  Rate Limit Monitor\n    getRecommendedService\n      × deve recomendar OpenAI quando dentro dos limites (1 ms)\n      × deve recomendar Claude quando OpenAI está próximo do limite (1 ms)\n      × deve recomendar Claude para requests muito grandes (1 ms)\n      × deve considerar janela de tempo para rate limiting\n    updateOpenAIUsage\n      × deve atualizar estatísticas de uso do OpenAI\n      × deve acumular múltiplas chamadas (1 ms)\n      × deve validar entrada de tokens\n    updateClaudeUsage\n      × deve atualizar estatísticas de uso do Claude\n      × deve acumular múltiplas chamadas do Claude (1 ms)\n    getUsageStats\n      × deve retornar estatísticas vazias inicialmente\n      × deve retornar estatísticas corretas após uso\n      × deve incluir limites configurados\n      × deve calcular tempo até reset (1 ms)\n    checkRateLimit\n      × deve permitir request quando dentro dos limites (1 ms)\n      × deve negar request quando excede limite (1 ms)\n      × deve validar parâmetros de entrada\n    resetStats\n      × deve resetar todas as estatísticas\n    getHealthStatus\n      × deve retornar status saudável quando tudo OK\n      × deve detectar quando OpenAI está próximo do limite\n      × deve detectar quando serviço está no limite\n\n  ● Rate Limit Monitor › getRecommendedService › deve recomendar OpenAI quando dentro dos limites\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getRecommendedService › deve recomendar OpenAI quando dentro dos limites\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getRecommendedService › deve recomendar Claude quando OpenAI está próximo do limite\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getRecommendedService › deve recomendar Claude quando OpenAI está próximo do limite\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getRecommendedService › deve recomendar Claude para requests muito grandes\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getRecommendedService › deve recomendar Claude para requests muito grandes\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getRecommendedService › deve considerar janela de tempo para rate limiting\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getRecommendedService › deve considerar janela de tempo para rate limiting\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › updateOpenAIUsage › deve atualizar estatísticas de uso do OpenAI\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › updateOpenAIUsage › deve atualizar estatísticas de uso do OpenAI\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › updateOpenAIUsage › deve acumular múltiplas chamadas\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › updateOpenAIUsage › deve acumular múltiplas chamadas\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › updateOpenAIUsage › deve validar entrada de tokens\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › updateOpenAIUsage › deve validar entrada de tokens\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › updateClaudeUsage › deve atualizar estatísticas de uso do Claude\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › updateClaudeUsage › deve atualizar estatísticas de uso do Claude\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › updateClaudeUsage › deve acumular múltiplas chamadas do Claude\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › updateClaudeUsage › deve acumular múltiplas chamadas do Claude\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getUsageStats › deve retornar estatísticas vazias inicialmente\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getUsageStats › deve retornar estatísticas vazias inicialmente\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getUsageStats › deve retornar estatísticas corretas após uso\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getUsageStats › deve retornar estatísticas corretas após uso\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getUsageStats › deve incluir limites configurados\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getUsageStats › deve incluir limites configurados\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getUsageStats › deve calcular tempo até reset\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getUsageStats › deve calcular tempo até reset\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › checkRateLimit › deve permitir request quando dentro dos limites\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › checkRateLimit › deve permitir request quando dentro dos limites\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › checkRateLimit › deve negar request quando excede limite\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › checkRateLimit › deve negar request quando excede limite\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › checkRateLimit › deve validar parâmetros de entrada\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › checkRateLimit › deve validar parâmetros de entrada\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › resetStats › deve resetar todas as estatísticas\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › resetStats › deve resetar todas as estatísticas\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getHealthStatus › deve retornar status saudável quando tudo OK\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getHealthStatus › deve retornar status saudável quando tudo OK\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getHealthStatus › deve detectar quando OpenAI está próximo do limite\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getHealthStatus › deve detectar quando OpenAI está próximo do limite\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\n  ● Rate Limit Monitor › getHealthStatus › deve detectar quando serviço está no limite\n\n    TypeError: rateLimitMonitor.resetStats is not a function\n\n    \u001b[0m \u001b[90m  5 |\u001b[39m     jest\u001b[33m.\u001b[39mclearAllMocks()\u001b[33m;\u001b[39m\n     \u001b[90m  6 |\u001b[39m     \u001b[90m// Reset internal state\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m     rateLimitMonitor\u001b[33m.\u001b[39mresetStats()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m  8 |\u001b[39m     \n     \u001b[90m  9 |\u001b[39m     \u001b[90m// Silenciar console para os testes\u001b[39m\n     \u001b[90m 10 |\u001b[39m     jest\u001b[33m.\u001b[39mspyOn(console\u001b[33m,\u001b[39m \u001b[32m'log'\u001b[39m)\u001b[33m.\u001b[39mmockImplementation()\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.resetStats (tests/unit/services/rateLimitMonitor.test.js:7:22)\n\n  ● Rate Limit Monitor › getHealthStatus › deve detectar quando serviço está no limite\n\n    TypeError: console.error.mockRestore is not a function\n\n    \u001b[0m \u001b[90m 16 |\u001b[39m     console\u001b[33m.\u001b[39mlog\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m 17 |\u001b[39m     console\u001b[33m.\u001b[39mwarn\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 18 |\u001b[39m     console\u001b[33m.\u001b[39merror\u001b[33m.\u001b[39mmockRestore()\u001b[33m;\u001b[39m\n     \u001b[90m    |\u001b[39m                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 19 |\u001b[39m   })\u001b[33m;\u001b[39m\n     \u001b[90m 20 |\u001b[39m\n     \u001b[90m 21 |\u001b[39m   describe(\u001b[32m'getRecommendedService'\u001b[39m\u001b[33m,\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.mockRestore (tests/unit/services/rateLimitMonitor.test.js:18:19)\n\nTest Suites: 1 failed, 1 total\nTests:       20 failed, 20 total\nSnapshots:   0 total\nTime:        0.498 s, estimated 2 s\n"
    },
    {
      "file": "tests/integration/auth.integration.test.js",
      "status": "FAILED",
      "error": "Command failed: npx jest \"tests/integration/auth.integration.test.js\" --verbose --no-coverage --silent\nFAIL tests/integration/auth.integration.test.js\n  Auth Integration Tests\n    POST /api/user/register\n      √ deve registrar novo usuário e retornar 201 (102 ms)\n      √ deve retornar 400 quando email já existe (8 ms)\n      √ deve validar campos obrigatórios (5 ms)\n      √ deve validar formato de email (5 ms)\n    POST /api/user/login\n      √ deve fazer login com credenciais válidas e retornar token (121 ms)\n      √ deve retornar 401 para senha incorreta (118 ms)\n      √ deve retornar 400 para email não cadastrado (4 ms)\n      √ deve validar campos obrigatórios no login (4 ms)\n    GET /api/user/profile\n      × deve retornar perfil do usuário autenticado (12 ms)\n      √ deve retornar 401 sem token de autorização (4 ms)\n      √ deve retornar 401 com token inválido (3 ms)\n      × deve retornar 404 quando usuário não existe (6 ms)\n    Fluxo completo de autenticação\n      × deve permitir registro -> login -> acesso ao perfil (183 ms)\n\n  ● Auth Integration Tests › GET /api/user/profile › deve retornar perfil do usuário autenticado\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 401\n\n    \u001b[0m \u001b[90m 240 |\u001b[39m\n     \u001b[90m 241 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 242 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 243 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody)\u001b[33m.\u001b[39mtoEqual(mockUser)\u001b[33m;\u001b[39m\n     \u001b[90m 244 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 245 |\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/auth.integration.test.js:242:31)\n\n  ● Auth Integration Tests › GET /api/user/profile › deve retornar 404 quando usuário não existe\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 404\n    Received: 401\n\n    \u001b[0m \u001b[90m 280 |\u001b[39m\n     \u001b[90m 281 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 282 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m404\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 283 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(\u001b[32m'não encontrado'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 284 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 285 |\u001b[39m   })\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/auth.integration.test.js:282:31)\n\n  ● Auth Integration Tests › Fluxo completo de autenticação › deve permitir registro -> login -> acesso ao perfil\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 401\n\n    \u001b[0m \u001b[90m 340 |\u001b[39m         \u001b[33m.\u001b[39m\u001b[36mset\u001b[39m(\u001b[32m'Authorization'\u001b[39m\u001b[33m,\u001b[39m \u001b[32m`Bearer ${loginResponse.body.token}`\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 341 |\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 342 |\u001b[39m       expect(profileResponse\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 343 |\u001b[39m       expect(profileResponse\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39memail)\u001b[33m.\u001b[39mtoBe(userData\u001b[33m.\u001b[39memail)\u001b[33m;\u001b[39m\n     \u001b[90m 344 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 345 |\u001b[39m   })\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/auth.integration.test.js:342:38)\n\nTest Suites: 1 failed, 1 total\nTests:       3 failed, 10 passed, 13 total\nSnapshots:   0 total\nTime:        1.828 s, estimated 3 s\n",
      "stderr": "FAIL tests/integration/auth.integration.test.js\n  Auth Integration Tests\n    POST /api/user/register\n      √ deve registrar novo usuário e retornar 201 (102 ms)\n      √ deve retornar 400 quando email já existe (8 ms)\n      √ deve validar campos obrigatórios (5 ms)\n      √ deve validar formato de email (5 ms)\n    POST /api/user/login\n      √ deve fazer login com credenciais válidas e retornar token (121 ms)\n      √ deve retornar 401 para senha incorreta (118 ms)\n      √ deve retornar 400 para email não cadastrado (4 ms)\n      √ deve validar campos obrigatórios no login (4 ms)\n    GET /api/user/profile\n      × deve retornar perfil do usuário autenticado (12 ms)\n      √ deve retornar 401 sem token de autorização (4 ms)\n      √ deve retornar 401 com token inválido (3 ms)\n      × deve retornar 404 quando usuário não existe (6 ms)\n    Fluxo completo de autenticação\n      × deve permitir registro -> login -> acesso ao perfil (183 ms)\n\n  ● Auth Integration Tests › GET /api/user/profile › deve retornar perfil do usuário autenticado\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 401\n\n    \u001b[0m \u001b[90m 240 |\u001b[39m\n     \u001b[90m 241 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 242 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 243 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody)\u001b[33m.\u001b[39mtoEqual(mockUser)\u001b[33m;\u001b[39m\n     \u001b[90m 244 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 245 |\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/auth.integration.test.js:242:31)\n\n  ● Auth Integration Tests › GET /api/user/profile › deve retornar 404 quando usuário não existe\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 404\n    Received: 401\n\n    \u001b[0m \u001b[90m 280 |\u001b[39m\n     \u001b[90m 281 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 282 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m404\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 283 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(\u001b[32m'não encontrado'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 284 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 285 |\u001b[39m   })\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/auth.integration.test.js:282:31)\n\n  ● Auth Integration Tests › Fluxo completo de autenticação › deve permitir registro -> login -> acesso ao perfil\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 401\n\n    \u001b[0m \u001b[90m 340 |\u001b[39m         \u001b[33m.\u001b[39m\u001b[36mset\u001b[39m(\u001b[32m'Authorization'\u001b[39m\u001b[33m,\u001b[39m \u001b[32m`Bearer ${loginResponse.body.token}`\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 341 |\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 342 |\u001b[39m       expect(profileResponse\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 343 |\u001b[39m       expect(profileResponse\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39memail)\u001b[33m.\u001b[39mtoBe(userData\u001b[33m.\u001b[39memail)\u001b[33m;\u001b[39m\n     \u001b[90m 344 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 345 |\u001b[39m   })\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/auth.integration.test.js:342:38)\n\nTest Suites: 1 failed, 1 total\nTests:       3 failed, 10 passed, 13 total\nSnapshots:   0 total\nTime:        1.828 s, estimated 3 s\n"
    },
    {
      "file": "tests/integration/payment.integration.test.js",
      "status": "FAILED",
      "error": "Command failed: npx jest \"tests/integration/payment.integration.test.js\" --verbose --no-coverage --silent\nFAIL tests/integration/payment.integration.test.js\n  Payment Integration Tests\n    POST /api/payment/create-intent\n      × deve criar payment intent com sucesso (41 ms)\n      × deve retornar 401 sem autenticação (6 ms)\n      × deve retornar 400 para valor inválido (5 ms)\n      × deve retornar 400 para valor menor que mínimo (8 ms)\n      × deve retornar 404 quando usuário não existe (6 ms)\n    POST /api/payment/confirm\n      × deve confirmar pagamento com sucesso (5 ms)\n      × deve retornar 404 quando payment intent não existe (3 ms)\n      × deve retornar 400 quando pagamento não foi bem-sucedido (4 ms)\n      × deve evitar processar transação já completada (6 ms)\n    POST /api/payment/webhook\n      × deve processar webhook de pagamento bem-sucedido (6 ms)\n      × deve retornar 400 para assinatura inválida (4 ms)\n      × deve ignorar eventos não relacionados a pagamento (6 ms)\n      × deve processar webhook de pagamento falhado (4 ms)\n    GET /api/payment/history\n      × deve retornar histórico de transações do usuário (5 ms)\n      √ deve retornar 401 sem autenticação (4 ms)\n      × deve retornar lista vazia para usuário sem transações (6 ms)\n    Fluxo completo de pagamento\n      × deve permitir criar intent -> confirmar pagamento -> verificar histórico (5 ms)\n\n  ● Payment Integration Tests › POST /api/payment/create-intent › deve criar payment intent com sucesso\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 503\n\n    \u001b[0m \u001b[90m 104 |\u001b[39m\n     \u001b[90m 105 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 106 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 107 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody)\u001b[33m.\u001b[39mtoHaveProperty(\u001b[32m'success'\u001b[39m\u001b[33m,\u001b[39m \u001b[36mtrue\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 108 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody)\u001b[33m.\u001b[39mtoHaveProperty(\u001b[32m'clientSecret'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 109 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39mclientSecret)\u001b[33m.\u001b[39mtoBe(\u001b[32m'pi_test123_secret'\u001b[39m)\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:106:31)\n\n  ● Payment Integration Tests › POST /api/payment/create-intent › deve retornar 401 sem autenticação\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 401\n    Received: 503\n\n    \u001b[0m \u001b[90m 140 |\u001b[39m\n     \u001b[90m 141 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 142 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m401\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 143 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 144 |\u001b[39m\n     \u001b[90m 145 |\u001b[39m     it(\u001b[32m'deve retornar 400 para valor inválido'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:142:31)\n\n  ● Payment Integration Tests › POST /api/payment/create-intent › deve retornar 400 para valor inválido\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 400\n    Received: 503\n\n    \u001b[0m \u001b[90m 160 |\u001b[39m\n     \u001b[90m 161 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 162 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m400\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 163 |\u001b[39m       expect(mockStripe\u001b[33m.\u001b[39mpaymentIntents\u001b[33m.\u001b[39mcreate)\u001b[33m.\u001b[39mnot\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 164 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 165 |\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:162:31)\n\n  ● Payment Integration Tests › POST /api/payment/create-intent › deve retornar 400 para valor menor que mínimo\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 400\n    Received: 503\n\n    \u001b[0m \u001b[90m 181 |\u001b[39m\n     \u001b[90m 182 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 183 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m400\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 184 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(\u001b[32m'mínimo'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 185 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 186 |\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:183:31)\n\n  ● Payment Integration Tests › POST /api/payment/create-intent › deve retornar 404 quando usuário não existe\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 404\n    Received: 503\n\n    \u001b[0m \u001b[90m 199 |\u001b[39m\n     \u001b[90m 200 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 201 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m404\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 202 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(\u001b[32m'não encontrado'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 203 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 204 |\u001b[39m   })\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:201:31)\n\n  ● Payment Integration Tests › POST /api/payment/confirm › deve confirmar pagamento com sucesso\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 503\n\n    \u001b[0m \u001b[90m 240 |\u001b[39m\n     \u001b[90m 241 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 242 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 243 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody)\u001b[33m.\u001b[39mtoHaveProperty(\u001b[32m'success'\u001b[39m\u001b[33m,\u001b[39m \u001b[36mtrue\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 244 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39mmessage)\u001b[33m.\u001b[39mtoContain(\u001b[32m'sucesso'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 245 |\u001b[39m       \u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:242:31)\n\n  ● Payment Integration Tests › POST /api/payment/confirm › deve retornar 404 quando payment intent não existe\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 404\n    Received: 503\n\n    \u001b[0m \u001b[90m 263 |\u001b[39m\n     \u001b[90m 264 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 265 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m404\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 266 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(\u001b[32m'não encontrado'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 267 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 268 |\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:265:31)\n\n  ● Payment Integration Tests › POST /api/payment/confirm › deve retornar 400 quando pagamento não foi bem-sucedido\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 400\n    Received: 503\n\n    \u001b[0m \u001b[90m 283 |\u001b[39m\n     \u001b[90m 284 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 285 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m400\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 286 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(\u001b[32m'não foi confirmado'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 287 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 288 |\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:285:31)\n\n  ● Payment Integration Tests › POST /api/payment/confirm › deve evitar processar transação já completada\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 503\n\n    \u001b[0m \u001b[90m 310 |\u001b[39m\n     \u001b[90m 311 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 312 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 313 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39mmessage)\u001b[33m.\u001b[39mtoContain(\u001b[32m'já foi processada'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 314 |\u001b[39m       expect(mockCompletedTransaction\u001b[33m.\u001b[39mupdate)\u001b[33m.\u001b[39mnot\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 315 |\u001b[39m     })\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:312:31)\n\n  ● Payment Integration Tests › POST /api/payment/webhook › deve processar webhook de pagamento bem-sucedido\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 400\n\n    \u001b[0m \u001b[90m 357 |\u001b[39m\n     \u001b[90m 358 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 359 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 360 |\u001b[39m       \n     \u001b[90m 361 |\u001b[39m       expect(mockStripe\u001b[33m.\u001b[39mwebhooks\u001b[33m.\u001b[39mconstructEvent)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m 362 |\u001b[39m         webhookPayload\u001b[33m,\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:359:31)\n\n  ● Payment Integration Tests › POST /api/payment/webhook › deve retornar 400 para assinatura inválida\n\n    expect(received).toContain(expected) // indexOf\n\n    Matcher error: received value must not be null nor undefined\n\n    Received has value: undefined\n\n    \u001b[0m \u001b[90m 383 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n     \u001b[90m 384 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m400\u001b[39m)\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 385 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(\u001b[32m'signature'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 386 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 387 |\u001b[39m\n     \u001b[90m 388 |\u001b[39m     it(\u001b[32m'deve ignorar eventos não relacionados a pagamento'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.toContain (tests/integration/payment.integration.test.js:385:35)\n\n  ● Payment Integration Tests › POST /api/payment/webhook › deve ignorar eventos não relacionados a pagamento\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 400\n\n    \u001b[0m \u001b[90m 401 |\u001b[39m\n     \u001b[90m 402 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 403 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 404 |\u001b[39m       expect(\u001b[33mTransaction\u001b[39m\u001b[33m.\u001b[39mfindOne)\u001b[33m.\u001b[39mnot\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 405 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 406 |\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:403:31)\n\n  ● Payment Integration Tests › POST /api/payment/webhook › deve processar webhook de pagamento falhado\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 400\n\n    \u001b[0m \u001b[90m 432 |\u001b[39m\n     \u001b[90m 433 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 434 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 435 |\u001b[39m       expect(mockTransaction\u001b[33m.\u001b[39mupdate)\u001b[33m.\u001b[39mtoHaveBeenCalledWith({ status\u001b[33m:\u001b[39m \u001b[32m'failed'\u001b[39m })\u001b[33m;\u001b[39m\n     \u001b[90m 436 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 437 |\u001b[39m   })\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:434:31)\n\n  ● Payment Integration Tests › GET /api/payment/history › deve retornar histórico de transações do usuário\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 401\n\n    \u001b[0m \u001b[90m 465 |\u001b[39m\n     \u001b[90m 466 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 467 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 468 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody)\u001b[33m.\u001b[39mtoHaveProperty(\u001b[32m'success'\u001b[39m\u001b[33m,\u001b[39m \u001b[36mtrue\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 469 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39mtransactions)\u001b[33m.\u001b[39mtoHaveLength(\u001b[35m2\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 470 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39mtransactions[\u001b[35m0\u001b[39m]\u001b[33m.\u001b[39mamount)\u001b[33m.\u001b[39mtoBe(\u001b[35m1000\u001b[39m)\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:467:31)\n\n  ● Payment Integration Tests › GET /api/payment/history › deve retornar lista vazia para usuário sem transações\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 401\n\n    \u001b[0m \u001b[90m 497 |\u001b[39m\n     \u001b[90m 498 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 499 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 500 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39mtransactions)\u001b[33m.\u001b[39mtoHaveLength(\u001b[35m0\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 501 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 502 |\u001b[39m   })\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:499:31)\n\n  ● Payment Integration Tests › Fluxo completo de pagamento › deve permitir criar intent -> confirmar pagamento -> verificar histórico\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 503\n\n    \u001b[0m \u001b[90m 535 |\u001b[39m         })\u001b[33m;\u001b[39m\n     \u001b[90m 536 |\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 537 |\u001b[39m       expect(createResponse\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                     \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 538 |\u001b[39m\n     \u001b[90m 539 |\u001b[39m       \u001b[90m// Etapa 2: Confirmar Pagamento\u001b[39m\n     \u001b[90m 540 |\u001b[39m       mockStripe\u001b[33m.\u001b[39mpaymentIntents\u001b[33m.\u001b[39mretrieve\u001b[33m.\u001b[39mmockResolvedValue({\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:537:37)\n\nTest Suites: 1 failed, 1 total\nTests:       16 failed, 1 passed, 17 total\nSnapshots:   0 total\nTime:        1.642 s, estimated 4 s\n",
      "stderr": "FAIL tests/integration/payment.integration.test.js\n  Payment Integration Tests\n    POST /api/payment/create-intent\n      × deve criar payment intent com sucesso (41 ms)\n      × deve retornar 401 sem autenticação (6 ms)\n      × deve retornar 400 para valor inválido (5 ms)\n      × deve retornar 400 para valor menor que mínimo (8 ms)\n      × deve retornar 404 quando usuário não existe (6 ms)\n    POST /api/payment/confirm\n      × deve confirmar pagamento com sucesso (5 ms)\n      × deve retornar 404 quando payment intent não existe (3 ms)\n      × deve retornar 400 quando pagamento não foi bem-sucedido (4 ms)\n      × deve evitar processar transação já completada (6 ms)\n    POST /api/payment/webhook\n      × deve processar webhook de pagamento bem-sucedido (6 ms)\n      × deve retornar 400 para assinatura inválida (4 ms)\n      × deve ignorar eventos não relacionados a pagamento (6 ms)\n      × deve processar webhook de pagamento falhado (4 ms)\n    GET /api/payment/history\n      × deve retornar histórico de transações do usuário (5 ms)\n      √ deve retornar 401 sem autenticação (4 ms)\n      × deve retornar lista vazia para usuário sem transações (6 ms)\n    Fluxo completo de pagamento\n      × deve permitir criar intent -> confirmar pagamento -> verificar histórico (5 ms)\n\n  ● Payment Integration Tests › POST /api/payment/create-intent › deve criar payment intent com sucesso\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 503\n\n    \u001b[0m \u001b[90m 104 |\u001b[39m\n     \u001b[90m 105 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 106 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 107 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody)\u001b[33m.\u001b[39mtoHaveProperty(\u001b[32m'success'\u001b[39m\u001b[33m,\u001b[39m \u001b[36mtrue\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 108 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody)\u001b[33m.\u001b[39mtoHaveProperty(\u001b[32m'clientSecret'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 109 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39mclientSecret)\u001b[33m.\u001b[39mtoBe(\u001b[32m'pi_test123_secret'\u001b[39m)\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:106:31)\n\n  ● Payment Integration Tests › POST /api/payment/create-intent › deve retornar 401 sem autenticação\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 401\n    Received: 503\n\n    \u001b[0m \u001b[90m 140 |\u001b[39m\n     \u001b[90m 141 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 142 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m401\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 143 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 144 |\u001b[39m\n     \u001b[90m 145 |\u001b[39m     it(\u001b[32m'deve retornar 400 para valor inválido'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:142:31)\n\n  ● Payment Integration Tests › POST /api/payment/create-intent › deve retornar 400 para valor inválido\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 400\n    Received: 503\n\n    \u001b[0m \u001b[90m 160 |\u001b[39m\n     \u001b[90m 161 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 162 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m400\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 163 |\u001b[39m       expect(mockStripe\u001b[33m.\u001b[39mpaymentIntents\u001b[33m.\u001b[39mcreate)\u001b[33m.\u001b[39mnot\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 164 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 165 |\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:162:31)\n\n  ● Payment Integration Tests › POST /api/payment/create-intent › deve retornar 400 para valor menor que mínimo\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 400\n    Received: 503\n\n    \u001b[0m \u001b[90m 181 |\u001b[39m\n     \u001b[90m 182 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 183 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m400\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 184 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(\u001b[32m'mínimo'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 185 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 186 |\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:183:31)\n\n  ● Payment Integration Tests › POST /api/payment/create-intent › deve retornar 404 quando usuário não existe\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 404\n    Received: 503\n\n    \u001b[0m \u001b[90m 199 |\u001b[39m\n     \u001b[90m 200 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 201 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m404\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 202 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(\u001b[32m'não encontrado'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 203 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 204 |\u001b[39m   })\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:201:31)\n\n  ● Payment Integration Tests › POST /api/payment/confirm › deve confirmar pagamento com sucesso\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 503\n\n    \u001b[0m \u001b[90m 240 |\u001b[39m\n     \u001b[90m 241 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 242 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 243 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody)\u001b[33m.\u001b[39mtoHaveProperty(\u001b[32m'success'\u001b[39m\u001b[33m,\u001b[39m \u001b[36mtrue\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 244 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39mmessage)\u001b[33m.\u001b[39mtoContain(\u001b[32m'sucesso'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 245 |\u001b[39m       \u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:242:31)\n\n  ● Payment Integration Tests › POST /api/payment/confirm › deve retornar 404 quando payment intent não existe\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 404\n    Received: 503\n\n    \u001b[0m \u001b[90m 263 |\u001b[39m\n     \u001b[90m 264 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 265 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m404\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 266 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(\u001b[32m'não encontrado'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 267 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 268 |\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:265:31)\n\n  ● Payment Integration Tests › POST /api/payment/confirm › deve retornar 400 quando pagamento não foi bem-sucedido\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 400\n    Received: 503\n\n    \u001b[0m \u001b[90m 283 |\u001b[39m\n     \u001b[90m 284 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 285 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m400\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 286 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(\u001b[32m'não foi confirmado'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 287 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 288 |\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:285:31)\n\n  ● Payment Integration Tests › POST /api/payment/confirm › deve evitar processar transação já completada\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 503\n\n    \u001b[0m \u001b[90m 310 |\u001b[39m\n     \u001b[90m 311 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 312 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 313 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39mmessage)\u001b[33m.\u001b[39mtoContain(\u001b[32m'já foi processada'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 314 |\u001b[39m       expect(mockCompletedTransaction\u001b[33m.\u001b[39mupdate)\u001b[33m.\u001b[39mnot\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 315 |\u001b[39m     })\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:312:31)\n\n  ● Payment Integration Tests › POST /api/payment/webhook › deve processar webhook de pagamento bem-sucedido\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 400\n\n    \u001b[0m \u001b[90m 357 |\u001b[39m\n     \u001b[90m 358 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 359 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 360 |\u001b[39m       \n     \u001b[90m 361 |\u001b[39m       expect(mockStripe\u001b[33m.\u001b[39mwebhooks\u001b[33m.\u001b[39mconstructEvent)\u001b[33m.\u001b[39mtoHaveBeenCalledWith(\n     \u001b[90m 362 |\u001b[39m         webhookPayload\u001b[33m,\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:359:31)\n\n  ● Payment Integration Tests › POST /api/payment/webhook › deve retornar 400 para assinatura inválida\n\n    expect(received).toContain(expected) // indexOf\n\n    Matcher error: received value must not be null nor undefined\n\n    Received has value: undefined\n\n    \u001b[0m \u001b[90m 383 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n     \u001b[90m 384 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m400\u001b[39m)\u001b[33m;\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 385 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39merror)\u001b[33m.\u001b[39mtoContain(\u001b[32m'signature'\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 386 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 387 |\u001b[39m\n     \u001b[90m 388 |\u001b[39m     it(\u001b[32m'deve ignorar eventos não relacionados a pagamento'\u001b[39m\u001b[33m,\u001b[39m \u001b[36masync\u001b[39m () \u001b[33m=>\u001b[39m {\u001b[0m\n\n      at Object.toContain (tests/integration/payment.integration.test.js:385:35)\n\n  ● Payment Integration Tests › POST /api/payment/webhook › deve ignorar eventos não relacionados a pagamento\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 400\n\n    \u001b[0m \u001b[90m 401 |\u001b[39m\n     \u001b[90m 402 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 403 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 404 |\u001b[39m       expect(\u001b[33mTransaction\u001b[39m\u001b[33m.\u001b[39mfindOne)\u001b[33m.\u001b[39mnot\u001b[33m.\u001b[39mtoHaveBeenCalled()\u001b[33m;\u001b[39m\n     \u001b[90m 405 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 406 |\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:403:31)\n\n  ● Payment Integration Tests › POST /api/payment/webhook › deve processar webhook de pagamento falhado\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 400\n\n    \u001b[0m \u001b[90m 432 |\u001b[39m\n     \u001b[90m 433 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 434 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 435 |\u001b[39m       expect(mockTransaction\u001b[33m.\u001b[39mupdate)\u001b[33m.\u001b[39mtoHaveBeenCalledWith({ status\u001b[33m:\u001b[39m \u001b[32m'failed'\u001b[39m })\u001b[33m;\u001b[39m\n     \u001b[90m 436 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 437 |\u001b[39m   })\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:434:31)\n\n  ● Payment Integration Tests › GET /api/payment/history › deve retornar histórico de transações do usuário\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 401\n\n    \u001b[0m \u001b[90m 465 |\u001b[39m\n     \u001b[90m 466 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 467 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 468 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody)\u001b[33m.\u001b[39mtoHaveProperty(\u001b[32m'success'\u001b[39m\u001b[33m,\u001b[39m \u001b[36mtrue\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 469 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39mtransactions)\u001b[33m.\u001b[39mtoHaveLength(\u001b[35m2\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 470 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39mtransactions[\u001b[35m0\u001b[39m]\u001b[33m.\u001b[39mamount)\u001b[33m.\u001b[39mtoBe(\u001b[35m1000\u001b[39m)\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:467:31)\n\n  ● Payment Integration Tests › GET /api/payment/history › deve retornar lista vazia para usuário sem transações\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 401\n\n    \u001b[0m \u001b[90m 497 |\u001b[39m\n     \u001b[90m 498 |\u001b[39m       \u001b[90m// Assert\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 499 |\u001b[39m       expect(response\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 500 |\u001b[39m       expect(response\u001b[33m.\u001b[39mbody\u001b[33m.\u001b[39mtransactions)\u001b[33m.\u001b[39mtoHaveLength(\u001b[35m0\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m 501 |\u001b[39m     })\u001b[33m;\u001b[39m\n     \u001b[90m 502 |\u001b[39m   })\u001b[33m;\u001b[39m\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:499:31)\n\n  ● Payment Integration Tests › Fluxo completo de pagamento › deve permitir criar intent -> confirmar pagamento -> verificar histórico\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 200\n    Received: 503\n\n    \u001b[0m \u001b[90m 535 |\u001b[39m         })\u001b[33m;\u001b[39m\n     \u001b[90m 536 |\u001b[39m\n    \u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 537 |\u001b[39m       expect(createResponse\u001b[33m.\u001b[39mstatus)\u001b[33m.\u001b[39mtoBe(\u001b[35m200\u001b[39m)\u001b[33m;\u001b[39m\n     \u001b[90m     |\u001b[39m                                     \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n     \u001b[90m 538 |\u001b[39m\n     \u001b[90m 539 |\u001b[39m       \u001b[90m// Etapa 2: Confirmar Pagamento\u001b[39m\n     \u001b[90m 540 |\u001b[39m       mockStripe\u001b[33m.\u001b[39mpaymentIntents\u001b[33m.\u001b[39mretrieve\u001b[33m.\u001b[39mmockResolvedValue({\u001b[0m\n\n      at Object.toBe (tests/integration/payment.integration.test.js:537:37)\n\nTest Suites: 1 failed, 1 total\nTests:       16 failed, 1 passed, 17 total\nSnapshots:   0 total\nTime:        1.642 s, estimated 4 s\n"
    }
  ]
}